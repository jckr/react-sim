{"version":3,"sources":["webpack:///./src/components/examples/snake/helpers.js","webpack:///./src/components/examples/snake/frames.js","webpack:///./src/components/examples/snake/data.js","webpack:///./src/components/examples/snake/index.js","webpack:///./src/pages/examples/snake.mdx"],"names":["DIRECTIONS","opposite","IS_VERTICAL","v","getDir","reduce","prev","curr","i","getRandomInBounds","min","max","random","Math","floor","isValid","x","y","visited","height","width","initVisited","grid","path","results","row","r","rowResults","cell","c","forEach","getShortestPath","start","end","length","paths","next","found","node","shift","d","step","concat","push","getLongestPath","stack","longestPath","updatedPath","extendPath","lastInLongestPath","nextInStack","dx","dy","rightPoints","leftPoints","unshift","getActionGrid","direction","totalPath","actionGrid","map","undefined","positionFruit","eligiblePositions","resultRow","SnakeBit","size","color","directionNext","directionPrev","weight","console","log","ms","ws","style","position","borderRadius","background","left","top","bottom","right","goesUp","goesLeft","topleft","topright","bottomleft","bottomright","cornerStyles","overflow","ActionBit","action","boxSizing","border","transformOrigin","transform","SnakeFrame","renderAG","props","data","params","cellSize","className","flexDirection","key","renderSnake","fruit","display","alignItems","justifyContent","renderFruit","render","this","margin","paddingBottom","React","Component","initSnake","directionRandom","directionText","initialLength","snakePosRandom","xHead","yHead","up","down","minX","maxX","minY","maxY","j","head","tail","snakePath","s","behindTail","frontOfSnake","initSnakeGrid","initSnakeGame","bestPath","updateSnake","complete","updatedActionGrid","updatedBestPath","fruitGrowth","safeMode","updatedGrid","updatedHead","every","updatedLength","updatedFruit","pathToFruit","tailToFruit","backToTail","addToGrid","updateSnakeGrid","updatedData","defaultProps","Snake","auto","maxTime","Infinity","initData","initialParams","updateData","SnakeGrid","_frontmatter","layoutProps","MDXContent","components","mdxType","parentName","isMDXComponent"],"mappings":"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","file":"component---src-pages-examples-snake-mdx-7619572d7eb64f29138b.js","sourcesContent":["// constants\n\nexport const UP = 0;\nexport const RIGHT = 1;\nexport const DOWN = 2;\nexport const LEFT = 3;\n\nexport const DIRECTIONS = [UP, RIGHT, DOWN, LEFT];\n\nexport const opposite = [DOWN, LEFT, UP, RIGHT];\nexport const IS_VERTICAL = [true, false, true, false];\nexport const IS_HORIZONTAL = [false, true, false, true];\n\nexport const v = [\n  [0, -1],\n  [1, 0],\n  [0, 1],\n  [-1, 0],\n];\n\nexport const getDir = v.reduce((prev, curr, i) => {\n  prev[curr] = i;\n  return prev;\n}, {});\n\n// helpers\n\nexport function getRandomInBounds(min, max, random = Math.random) {\n  // returns a random integer within [min, max]\n  // (bounds are included)\n  return min + Math.floor(random() * (max + 1 - min));\n}\n\nexport function isValid(x, y, visited, height, width) {\n  // returns whether one of the pathfinding functions can consider a cell\n  if (x < 0 || x > width - 1 || y < 0 || y > height - 1) {\n    return false;\n  }\n  if (visited[[x, y]]) {\n    return false;\n  }\n  return true;\n}\n\nexport function initVisited(grid = [[]], path = []) {\n  // refreshes the \"visited\" object\n  // every snake cell in the grid is marked as visited,\n  // every cell in the path as well.\n  // both are optional.\n\n  // because this is an object, it can be inadvertantly mutated\n  // so it's safer to reinitialize it after each use\n  const visited = grid.reduce(\n    (results, row, r) =>\n      row.reduce((rowResults, cell, c) => {\n        if (cell > 0) {\n          rowResults[[c, r]] = true;\n        }\n        return rowResults;\n      }, results),\n    {}\n  );\n  path.forEach(([r, c]) => (visited[[r, c]] = true));\n  return visited;\n}\n\nexport function getShortestPath({ grid, start, end }) {\n  // finds shortest path between start and end given status of a grid\n  // where visited cells can't be crossed\n\n  const height = grid.length;\n  if (height === 0) {\n    return [];\n  }\n  const width = grid[0].length;\n\n  const visited = initVisited(grid);\n  delete visited[end];\n  // paths - for each node, shortest path to reach that node from start\n  const paths = {};\n  const next = [start];\n  paths[start] = [start];\n  let found = false;\n  while (next.length && !found) {\n    const node = next.shift();\n    /* eslint-disable no-loop-func */\n    DIRECTIONS.forEach(d => {\n      // step is next node in that direction, from node\n      const step = [node[0] + v[d][0], node[1] + v[d][1]];\n      const [x, y] = step;\n      if (!isValid(x, y, visited, height, width)) {\n        return;\n      }\n      visited[step] = true;\n      paths[step] = paths[node].concat([step]);\n      if (x === end[0] && y === end[1]) {\n        found = true;\n      }\n      // we add each step to our queue. it's important to do BFS here\n      next.push(step);\n    });\n  }\n  // out shortest path\n  return paths[end];\n}\n\nexport function getLongestPath({ grid, start, end }) {\n  const height = grid.length;\n  if (height === 0) {\n    return [];\n  }\n  const width = grid[0].length;\n\n  let stack = getShortestPath({\n    grid,\n    start,\n    end,\n  }) || [start];\n\n  let visited = initVisited(grid, stack);\n  let longestPath = [stack.shift()];\n\n  // the general idea is that we start from the shortest path from start\n  // to end.\n\n  // then, for each segment in that path, we try to see if we can extend\n  // it by adding a pair of adjacent points.\n  // we continue until we run out of pair of points we can add to that path.\n\n  while (stack.length) {\n    const updatedPath = extendPath({\n      height,\n      longestPath,\n      stack,\n      visited,\n      width,\n    });\n    stack = updatedPath.stack;\n    visited = updatedPath.visited;\n    longestPath = updatedPath.longestPath;\n  }\n\n  return longestPath;\n}\n\nexport function extendPath({ height, longestPath, stack, visited, width }) {\n  const lastInLongestPath = longestPath[longestPath.length - 1];\n  visited[lastInLongestPath] = true;\n  const nextInStack = stack.shift();\n\n  // last in path to next in stack form a segment.\n  // we are trying to see if the 2 points to the right, or 2 points to the left are\n  // valid. if so, we'll add them to the stack.\n\n  // ie - last in path = l, next in stack = n, valid = ., invalid = x\n  // xxxxxx xxxxxxx xxxxxxx xxxxxxx\n  // x.n..x x.....x x.....x x.x...x\n  // x.lx.x x..ln.x xxl...x x.nl..x\n  // x....x x..x..x x.n...x x.....x\n  // xxxxxx xxxxxxx xxxxxxx xxxxxxx\n  //\n  // in each of these 4 examples, 2 points to the left of ln are both valid.\n  // so we can push them to the stack\n  // only one of the 2 points to the right of ln are valid. so we can't push them to the stack\n  // not 100% sure of that, but i think with how we build the path, having 2 points to right\n  // valid and 2 points to left valid is exclusive.\n  // valid points = not visited, not off bounds\n\n  const dx = nextInStack[0] - lastInLongestPath[0];\n  const dy = nextInStack[1] - lastInLongestPath[1];\n\n  const rightPoints = [\n    [lastInLongestPath[0] - dy, lastInLongestPath[1] - dx],\n    [nextInStack[0] - dy, nextInStack[1] - dx],\n  ];\n  const leftPoints = [\n    [lastInLongestPath[0] + dy, lastInLongestPath[1] + dx],\n    [nextInStack[0] + dy, nextInStack[1] + dx],\n  ];\n\n  if (\n    isValid(...rightPoints[0], visited, height, width) &&\n    isValid(...rightPoints[1], visited, height, width)\n  ) {\n    stack.unshift(nextInStack);\n    stack.unshift(rightPoints[1]);\n    stack.unshift(rightPoints[0]);\n    visited[rightPoints[0]] = true;\n    visited[rightPoints[1]] = true;\n  } else {\n    if (\n      isValid(...leftPoints[0], visited, height, width) &&\n      isValid(...leftPoints[1], visited, height, width)\n    ) {\n      stack.unshift(nextInStack);\n      stack.unshift(leftPoints[1]);\n      stack.unshift(leftPoints[0]);\n      visited[leftPoints[0]] = true;\n      visited[leftPoints[1]] = true;\n    } else {\n      // we can't add either both right points or both left points to stack.\n      // Great! we add nextInStack to the path, and continue.\n      longestPath.push(nextInStack);\n    }\n  }\n  return { stack, visited, longestPath };\n}\n\nexport function getActionGrid({ grid, path = [], direction, stack = [] }) {\n  // we have on one hand, grid which is the position of the snake,\n  // and on the other, path which is the longest path from the cell\n  // which is in front of the snake to the one behind its tail.\n\n  // what we want is a lookup table that, for every coordinate that the\n  // head could find itself on, suggest the corresponding, safe action.\n\n  const totalPath = [...path, ...stack];\n  const actionGrid = grid.map(row =>\n    row.map(cell => (cell ? direction : undefined))\n  );\n  if (totalPath.length < 2) {\n    return actionGrid;\n  }\n  let node;\n\n  for (let i = 1; i < totalPath.length; i++) {\n    const prev = totalPath[i - 1];\n    node = totalPath[i];\n    const dx = node[0] - prev[0];\n    const dy = node[1] - prev[1];\n    const [c, r] = prev;\n    actionGrid[r][c] = getDir[[dx, dy]];\n  }\n\n  // we should have a complete actionGrid except for the very last node\n  // of path\n\n  // it goes towards the tail of the snake. in our case it's direction\n  if (direction) {\n    const [c, r] = node;\n\n    actionGrid[r][c] = direction;\n  }\n  return actionGrid;\n}\n\nexport function isFullGrid(actionGrid) {\n  return actionGrid.every(row => row.every(cell => cell !== undefined));\n}\n\nexport function positionFruit(grid, random = Math.random) {\n  const eligiblePositions = grid.reduce(\n    (results, row, r) =>\n      row.reduce((resultRow, cell, c) => {\n        if (cell === 0) {\n          resultRow.push([r, c]);\n        }\n        return resultRow;\n      }, results),\n    []\n  );\n  if (eligiblePositions.length === 0) {\n    return null;\n  }\n  const randomPosition = Math.floor(random() * eligiblePositions.length);\n  return eligiblePositions[randomPosition];\n}\n\nexport function addToGrid(grid, path) {\n  const updatedGrid = grid.map(row => row.map(cell => cell));\n  path.forEach(([c, r]) => (updatedGrid[r][c] = 1));\n  return updatedGrid;\n}\n","import React from 'react';\nimport { Flex } from 'rebass';\n\nimport {IS_VERTICAL, UP, RIGHT, DOWN, LEFT, opposite} from './helpers';\n\nconst SnakeBit = ({ size, color, directionNext, directionPrev, weight }) => {\n  if (directionNext === null) {\n    // tail\n    if (directionPrev === null) {\n      console.log('warning - double null');\n      return null;\n    }\n    return SnakeBit({\n      size,\n      color,\n      weight,\n      directionNext: directionPrev,\n      directionPrev: null,\n    });\n  }\n  const margin = (1 - weight) / 2;\n  const ms = margin * size;\n  const ws = weight * size;\n\n  if (directionPrev === null) {\n    // head, or \"reversed tail\"\n    return (\n      <div style={{ height: size, width: size, position: 'relative' }}>\n        <div\n          style={{\n            borderRadius: '50%',\n            height: ws,\n            width: ws,\n            background: color,\n            left: ms,\n            top: ms,\n            position: 'absolute',\n          }}\n        />\n        <div\n          style={{\n            position: 'absolute',\n            background: color,\n            ...(IS_VERTICAL[directionNext]\n              ? { width: ws, left: ms, height: size / 2 }\n              : { width: size / 2, top: ms, height: ws }),\n            ...(directionNext === UP ? { top: 0 } : {}),\n            ...(directionNext === DOWN ? { bottom: 0 } : {}),\n            ...(directionNext === LEFT ? { left: 0 } : {}),\n            ...(directionNext === RIGHT ? { right: 0 } : {}),\n          }}\n        />\n      </div>\n    );\n  }\n  if (directionNext === opposite[directionPrev]) {\n    // vertical, or horizontal\n    return (\n      <div style={{ height: size, width: size, position: 'relative' }}>\n        <div\n          style={{\n            position: 'absolute',\n            background: color,\n            ...(IS_VERTICAL[directionNext]\n              ? {\n                  width: ws,\n                  height: size,\n                  left: ms,\n                }\n              : { width: size, height: ws, top: ms }),\n          }}\n        />\n      </div>\n    );\n  }\n  // corner\n\n  const goesUp = directionNext === UP || directionPrev === UP;\n  const goesLeft = directionNext === LEFT || directionPrev === LEFT;\n\n  const direction = goesUp\n    ? goesLeft\n      ? 'topleft'\n      : 'topright'\n    : goesLeft\n    ? 'bottomleft'\n    : 'bottomright';\n\n  const borderRadius = {\n    topleft: '0 0 100% 0',\n    topright: '0 0 0 100%',\n    bottomleft: '0 100% 0 0',\n    bottomright: '100% 0 0 0',\n  }[direction];\n\n  const position = {\n    ...(goesUp ? { top: 0 } : { bottom: 0 }),\n    ...(goesLeft ? { left: 0 } : { right: 0 }),\n  };\n\n  const cornerStyles = {\n    borderRadius,\n    ...position,\n  };\n\n  return (\n    <div\n      style={{\n        height: size,\n        width: size,\n        position: 'relative',\n        overflow: 'hidden',\n      }}\n    >\n      <div\n        style={{\n          position: 'absolute',\n          background: color,\n          width: ws + ms,\n          height: ws + ms,\n          ...cornerStyles,\n        }}\n      />\n      <div\n        style={{\n          position: 'absolute',\n          background: 'white',\n          width: ms,\n          height: ms,\n          ...cornerStyles,\n        }}\n      />\n    </div>\n  );\n};\n\nconst ActionBit = ({ size, action }) => (\n  <div\n    style={{\n      boxSizing: 'border-box',\n      position: 'relative',\n      height: size,\n      width: size,\n      border: '1px solid #eee',\n    }}\n  >\n    <div\n      style={{\n        position: 'absolute',\n        height: 0,\n        width: size - 1,\n        border: action === undefined ? 'none' : '1px dashed #555',\n        transformOrigin: '0 100%',\n        left: (size - 1) / 2,\n        top: (size - 1) / 2,\n        transform: `rotate(${(action - 1) * 90}deg)`,\n      }}\n    />\n  </div>\n);\n\nexport class SnakeFrame extends React.Component {\n  static defaultProps = {\n    width: 30,\n    height: 30,\n    initialLength: 4,\n  };\n  renderAG = () => {\n    const { actionGrid } = this.props?.data;\n    if (!actionGrid) {\n      return null;\n    }\n    const { cellSize: size } = this.props.params;\n\n    return (\n      <div className=\"actions\" style={{ position: 'absolute' }}>\n        {actionGrid.map((row, r) => (\n          <Flex flexDirection='row'  key={`ar-${r}`}>\n            {row.map((cell, c) => (\n              <ActionBit size={size} action={cell} key={`arc-${r}-${c}`} />\n            ))}\n          </Flex>\n        ))}\n      </div>\n    );\n  };\n\n  renderSnake = () => {\n    const { cellSize: size } = this.props.params;\n    const { grid, fruit } = this.props?.data;\n    if (!grid) {\n      return null;\n    }\n    return (\n      <Flex flexDirection='column'  className=\"snake\">\n        {grid.map((row, r) => (\n          <Flex flexDirection='row'  key={`sr-${r}`}>\n            {row.map((cell, c) => {\n              if (cell === 0) {\n                return (\n                  <div\n                    key={`fruit-${r}-${c}`}\n                    style={{\n                      width: size,\n                      height: size,\n                      display: 'flex',\n                      alignItems: 'center',\n                      justifyContent: 'center',\n                    }}\n                  >\n                    {fruit && c === fruit[0] && r === fruit[1] ? '🍎' : ''}\n                  </div>\n                );\n              } else {\n                let directionNext = null;\n                let directionPrev = null;\n                if (grid[r][c + 1]) {\n                  if (grid[r][c + 1] === cell + 1) {\n                    directionPrev = RIGHT;\n                  }\n                  if (grid[r][c + 1] === cell - 1) {\n                    directionNext = RIGHT;\n                  }\n                }\n                if (grid[r][c - 1]) {\n                  if (grid[r][c - 1] === cell + 1) {\n                    directionPrev = LEFT;\n                  }\n                  if (grid[r][c - 1] === cell - 1) {\n                    directionNext = LEFT;\n                  }\n                }\n                if (grid[r + 1] && grid[r + 1][c]) {\n                  if (grid[r + 1][c] === cell + 1) {\n                    directionPrev = DOWN;\n                  }\n                  if (grid[r + 1][c] === cell - 1) {\n                    directionNext = DOWN;\n                  }\n                }\n                if (grid[r - 1] && grid[r - 1][c]) {\n                  if (grid[r - 1][c] === cell + 1) {\n                    directionPrev = UP;\n                  }\n                  if (grid[r - 1][c] === cell - 1) {\n                    directionNext = UP;\n                  }\n                }\n                return (\n                  <SnakeBit\n                    size={size}\n                    weight={0.8}\n                    color=\"green\"\n                    directionNext={directionNext}\n                    directionPrev={directionPrev}\n                    key={`src-${r}-${c}`}\n                  />\n                );\n              }\n            })}\n          </Flex>\n        ))}\n      </Flex>\n    );\n  };\n  renderFruit() {}\n  render() {\n    const { data } = this.props;\n    if (data === null) {\n      return null;\n    }\n\n    const { actionGrid, grid } = data;\n    const { width, height, cellSize } = this.props.params;\n    return (\n      <div\n        style={{\n          boxSizing: 'content-box',\n          width: width * cellSize,\n          height: height * cellSize,\n          margin: '0 auto',\n          paddingBottom: cellSize,\n        }}\n      >\n        {this.renderAG()}\n        {this.renderSnake()}\n        {this.renderFruit()}\n      </div>\n    );\n  }\n}\n","import {\n  UP,\n  RIGHT,\n  DOWN,\n  LEFT,\n  addToGrid,\n  extendPath,\n  getActionGrid,\n  getLongestPath,\n  getRandomInBounds,\n  getShortestPath,\n  initVisited,\n  opposite,\n  positionFruit,\n  v,\n} from './helpers';\n\n// init\n\nexport function initSnake(\n  {\n    directionRandom,\n    directionText,\n    height,\n    width,\n    initialLength,\n    snakePosRandom,\n    xHead,\n    yHead,\n  },\n  random = Math.random\n) {\n  const direction = directionRandom\n    ? Math.floor(random() * 4)\n    : { up: 0, right: 1, down: 2, left: 3 }[directionText];\n\n  // position of snake head\n\n  const minX = direction === RIGHT ? initialLength + 2 : 2;\n  const maxX = width - 1 - (direction === LEFT ? initialLength + 2 : 2);\n  const minY = direction === DOWN ? initialLength + 2 : 2;\n  const maxY = height - 1 - (direction === UP ? initialLength + 2 : 2);\n\n  if (snakePosRandom) {\n    // bounding box where the snake head can be\n\n    xHead = getRandomInBounds(minX, maxX, random);\n    yHead = getRandomInBounds(minY, maxY, random);\n  } else {\n    xHead = Math.min(maxX, Math.max(minX, xHead));\n    yHead = Math.min(maxY, Math.max(minY, yHead));\n  }\n\n  // initial empty grid\n\n  const grid = [];\n  for (let i = 0; i < height; i++) {\n    const row = [];\n    for (let j = 0; j < width; j++) {\n      row.push(0);\n    }\n    grid.push(row);\n  }\n\n  const head = [xHead, yHead];\n  let tail = [];\n  let snakePath = [];\n  // positioning snake\n\n  for (let s = 0; s < initialLength; s++) {\n    // opposite[direction] - if direction is right, we\n    // want to draw snake left of its head\n\n    // v - x,y vector of movement for a direction\n\n    const x = xHead + s * v[opposite[direction]][0];\n    const y = yHead + s * v[opposite[direction]][1];\n\n    // grid - 1 = head, 2 ... n = body of snake, 0 = empty cells\n    grid[y][x] = s + 1;\n\n    snakePath.unshift([x, y]);\n    // tail will be overwritten until the actual tail isn't\n    tail = [x, y];\n  }\n\n  const behindTail = [\n    tail[0] + v[opposite[direction]][0],\n    tail[1] + v[opposite[direction]][1],\n  ];\n\n  const frontOfSnake = [xHead + v[direction][0], yHead + v[direction][1]];\n\n  return {\n    behindTail,\n    direction,\n    frontOfSnake,\n    grid,\n    length: initialLength,\n    head,\n    snakePath,\n    tail,\n  };\n}\n\nexport function initSnakeGrid(params, random = Math.random) {\n  const { grid, head, tail, direction, snakePath } = initSnake(params, random);\n\n  const stack = getShortestPath({ grid, start: head, end: tail });\n  const visited = initVisited(grid, stack);\n  const longestPath = [...snakePath, stack.shift()];\n\n  const actionGrid = getActionGrid({\n    grid,\n    path: longestPath,\n    stack,\n    direction,\n  });\n  return {\n    actionGrid,\n    direction,\n    grid,\n    stack,\n    visited,\n    longestPath,\n  };\n}\n\nexport function initSnakeGame(params, random = Math.random) {\n  const {\n    grid,\n    head,\n    tail,\n    direction,\n    length,\n    snakePath,\n  } = initSnake(params, random);\n\n  const fruit = positionFruit(grid, random);\n\n  const longestPath = getLongestPath({\n    grid,\n    start: head,\n    end: tail,\n  });\n\n  const actionGrid = getActionGrid({ grid, path: longestPath, direction });\n\n  return {\n    head,\n    grid,\n    direction,\n    actionGrid,\n    fruit,\n    length,\n    snakePath,\n    bestPath: false,\n  };\n}\n\n// update\n\nexport function updateSnake({ data, params, complete }, random = Math.random) {\n  const { actionGrid, bestPath, grid, direction, head, fruit, length } = data;\n  let updatedActionGrid = actionGrid;\n  let updatedBestPath = bestPath;\n  const { fruitGrowth, height, width, safeMode } = params;\n  let snakePath = [];\n  const updatedGrid = grid.map((row, r) =>\n    row.map((cell, c) => {\n      if (cell === 0 || cell + 1 > length) {\n        return 0;\n      }\n      snakePath[length - cell - 1] = [c, r];\n      return cell + 1;\n    })\n  );\n  while (snakePath[0] === undefined) {\n    snakePath.shift();\n  }\n  const tail = snakePath[0];\n\n  // new position of head, based on previous direction\n  const updatedHead = [head[0] + v[direction][0], head[1] + v[direction][1]];\n\n  if (\n    // collision with snake\n    updatedGrid[updatedHead[1]][updatedHead[0]] !== 0 ||\n    // collision with walls\n    updatedHead[0] >= width ||\n    updatedHead[0] < 0 ||\n    updatedHead[1] >= height ||\n    updatedHead[1] < 0\n  ) {\n    // ouch\n    complete();\n  }\n\n  // updating grid\n  updatedGrid[updatedHead[1]][updatedHead[0]] = 1;\n\n  if (updatedGrid.every(row => row.every(cell => cell))) {\n    // full grid\n    complete();\n  }\n\n  // checking if fruit is eaten, if so, increasing length - repositioning fruit\n  let updatedLength = length;\n  let updatedFruit = fruit ? [fruit[0], fruit[1]] : [-1, -1];\n  if (\n    updatedHead[0] === updatedFruit[0] &&\n    updatedHead[1] === updatedFruit[1]\n  ) {\n    updatedLength = Math.min(height * width, updatedLength + fruitGrowth);\n    if (!safeMode) {\n      // in safe mode, once we find a path that covers the grid, we stick\n      // to it until the end. in unsafe mode, we try to improve it with\n      // each fruit.\n      updatedBestPath = false;\n    }\n    updatedFruit = positionFruit(updatedGrid, random);\n  }\n\n  // figuring out if action grid should be updated\n\n  if (updatedBestPath === false) {\n    const pathToFruit = getShortestPath({\n      grid,\n      start: updatedHead,\n      end: updatedFruit,\n    });\n    if (pathToFruit) {\n      const tailToFruit = [...snakePath, ...pathToFruit];\n      const candidateGrid = addToGrid(updatedGrid, tailToFruit);\n      const backToTail = getLongestPath({\n        grid: candidateGrid,\n        start: updatedFruit,\n        end: tail,\n      });\n      if (tailToFruit.length + backToTail.length === height * width + 2) {\n        // we found a way to go quickly but safely to the next fruit!\n\n        updatedActionGrid = getActionGrid({\n          grid,\n          path: tailToFruit,\n          stack: backToTail,\n        });\n\n        // no need to reevaluate it until next fruit\n        updatedBestPath = true;\n      }\n    }\n  }\n  // computing next direction, thanks to the action grid\n  const updatedDirection = updatedActionGrid[updatedHead[1]][updatedHead[0]];\n\n  return {\n    actionGrid: updatedActionGrid,\n    bestPath: updatedBestPath,\n    direction: updatedDirection,\n    fruit: updatedFruit,\n    grid: updatedGrid,\n    head: updatedHead,\n    length: updatedLength,\n    snakePath,\n  };\n}\n\nexport function updateSnakeGrid({ data, params, complete }) {\n  const { direction, grid, longestPath, stack, visited } = data;\n  const { height, width } = params;\n  const updatedData = extendPath({\n    height,\n    longestPath,\n    stack,\n    visited,\n    width,\n  });\n  const actionGrid = getActionGrid({\n    grid,\n    path: longestPath,\n    stack,\n    direction,\n  });\n  if (stack.length === 0) {\n    complete();\n  }\n  return {\n    actionGrid,\n    direction,\n    grid,\n    longestPath: updatedData.longestPath,\n    stack: updatedData.stack,\n    visited: updatedData.visited,\n  };\n}\n","import React from 'react';\nimport Model from '../framed-model';\nimport { SnakeFrame } from './frames';\nimport {\n  initSnakeGame,\n  initSnakeGrid,\n  updateSnake,\n  updateSnakeGrid,\n} from './data';\n\n// update\n\nconst Snake = () => (\n  <Model\n    auto={false}\n    maxTime={Infinity}\n    initData={initSnakeGame}\n    initialParams={{\n      cellSize: 32,\n      fruitGrowth: 4,\n      height: 10,\n      width: 10,\n      initialLength: 2,\n      safeMode: true,\n      snakePosRandom: true,\n      directionRandom: true,\n    }}\n    updateData={updateSnake}\n  >\n    <SnakeFrame />\n  </Model>\n);\n\nexport default Snake;\n\nexport const SnakeGrid = () => (\n  <Model\n    auto={false}\n    maxTime={Infinity}\n    initData={initSnakeGrid}\n    initialParams={{\n      cellSize: 16,\n      fruitGrowth: 4,\n      height: 20,\n      width: 20,\n      initialLength: 2,\n      snakePosRandom: true,\n      directionRandom: true,\n    }}\n    updateData={updateSnakeGrid}\n  >\n    <SnakeFrame />\n  </Model>\n);\n\nexport const SnakeGridDebugger = () => (\n  <Model\n    auto={false}\n    maxTime={Infinity}\n    initData={initSnakeGrid}\n    initialParams={{\n      cellSize: 25,\n      fruitGrowth: 4,\n      height: 10,\n      width: 10,\n      initialLength: 4,\n      xHead: 8,\n      yHead: 2,\n      directionText: 'right',\n      snakePosRandom: false,\n      directionRandom: false,\n      ticksPerAnimation: 1000,\n    }}\n    controls={[\n      {\n        type: 'range',\n        param: 'xHead',\n        minValue: 2,\n        maxValue: 18,\n        resetOnChange: true,\n      },\n      {\n        type: 'range',\n        param: 'yHead',\n        minValue: 2,\n        maxValue: 18,\n        resetOnChange: true,\n      },\n      {\n        type: 'radio',\n        param: 'directionText',\n        options: ['up', 'right', 'down', 'left'],\n        resetOnChange: true,\n      },\n    ]}\n    updateData={updateSnakeGrid}\n  >\n    <SnakeFrame />\n  </Model>\n);\n","import * as React from 'react'\n  /* @jsx mdx */\nimport { mdx } from '@mdx-js/react';\n/* @jsx mdx */\n\nimport Snake, { SnakeGrid } from '../../components/examples/snake/index';\nexport const _frontmatter = {\n  \"Title\": \"Snake\"\n};\n\nconst makeShortcode = name => function MDXDefaultShortcode(props) {\n  console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n  return <div {...props} />;\n};\n\nconst layoutProps = {\n  _frontmatter\n};\nconst MDXLayout = \"wrapper\";\nexport default function MDXContent({\n  components,\n  ...props\n}) {\n  return <MDXLayout {...layoutProps} {...props} components={components} mdxType=\"MDXLayout\">\n\n    <h1 {...{\n      \"id\": \"snake\"\n    }}>{`Snake`}</h1>\n    <Snake mdxType=\"Snake\" />\n    <p>{`This model tries to win the game of `}<a parentName=\"p\" {...{\n        \"href\": \"https://en.wikipedia.org/wiki/Snake_(video_game_genre)%3E\"\n      }}>{`Snake`}</a>{`.`}</p>\n    <p>{`A snake moves on a 2d grid. It can go straight, turn left or right. If it hits the borders of the grid or a part of its body, the game is over. If the snake eats a fruit, it grows in size. The goal of the game is to eat all the fruits, until the snake covers the entirety of the grid.`}</p>\n    <p>{`The way the model works is by finding a circuit which is safe for the snake to use. If we can find a circuit that covers the whole grid, then the snake can loop on that circuit endlessly and never collide with anything else than with a fruit.\nHow do we find such a circuit? We start by finding the `}<em parentName=\"p\">{`shortest path`}</em>{` between the head and the tail of the snake. Then, we see how we can extend this path step by step. This other model shows how this works:`}</p>\n    <SnakeGrid mdxType=\"SnakeGrid\" />\n\n    </MDXLayout>;\n}\n;\nMDXContent.isMDXComponent = true;\n      "],"sourceRoot":""}