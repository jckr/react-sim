{"version":3,"sources":["webpack:///./src/components/examples/game-of-life.js","webpack:///./src/pages/tutorial.mdx"],"names":["countNeighbors","x","y","grid","height","length","width","n","xOffset","yOffset","x1","y1","updateGameOfLifeGrid","data","complete","changes","updatedGrid","map","row","cell","neighbors","updateGridNoComplete","initGrid","density","Array","fill","Number","Math","random","GameOfLifeFrame","render","this","props","accessor","size","index","key","styles","overflow","alignItems","justifyContent","style","background","borderRadius","React","Component","defaultProps","d","Frame","initData","display","flexDirection","Step2","initialParams","Step3","updateData","Step4","Step5","controls","param","resetOnChange","maxValue","step","label","showTimeSlider","GameOfLife","auto","delay","_frontmatter","layoutProps","MDXContent","components","mdxType","parentName","isMDXComponent"],"mappings":"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","file":"component---src-pages-tutorial-mdx-49310872b4194595bbee.js","sourcesContent":["import React from 'react';\nimport { FlexRow, FlexColumn, Model } from 'react-sim';\n\n// helpers\n\nfunction countNeighbors(x, y, grid) {\n  const height = grid.length;\n  if (!height) {\n    return 0;\n  }\n  const width = grid[0].length;\n\n  let n = 0;\n  for (let xOffset = -1; xOffset <= 1; xOffset++) {\n    for (let yOffset = -1; yOffset <= 1; yOffset++) {\n      const x1 = x + xOffset;\n      const y1 = y + yOffset;\n      if (\n        x1 < width &&\n        x1 > 0 &&\n        y1 < height &&\n        y1 > 0 &&\n        (x1 !== x || y1 !== y)\n      ) {\n        n += grid[y1][x1];\n      }\n    }\n  }\n  return n;\n}\n\nexport function updateGameOfLifeGrid({ data, complete }) {\n  let changes = 0;\n  const updatedGrid = data.map((row, y) =>\n    row.map((cell, x) => {\n      const neighbors = countNeighbors(x, y, data);\n      if (cell && (neighbors < 2 || neighbors > 3)) {\n        // living cell has too few or too many neighbors, and dies.\n        changes++;\n        return 0;\n      }\n      if (!cell && neighbors === 3) {\n        // dead cell has the right amount of neighbors, and lives!\n        changes++;\n        return 1;\n      }\n      // no change\n      return cell;\n    })\n  );\n  if (changes === 0) {\n    complete();\n  }\n  return updatedGrid;\n}\n\nexport function updateGridNoComplete({ data }) {\n  return data.map((row, y) =>\n    row.map((cell, x) => {\n      const neighbors = countNeighbors(x, y, data);\n      if (cell && (neighbors < 2 || neighbors > 3)) {\n        // living cell has too few or too many neighbors, and dies.\n        return 0;\n      }\n      if (!cell && neighbors === 3) {\n        // dead cell has the right amount of neighbors, and lives!\n        return 1;\n      }\n      // no change\n      return cell;\n    })\n  );\n}\n\nfunction initGrid({ height, width, density }) {\n  return Array(height)\n    .fill(0)\n    .map(row =>\n      Array(width)\n        .fill(0)\n        .map(() => Number(Math.random() < density))\n    );\n}\n\nexport class GameOfLifeFrame extends React.Component {\n  static defaultProps = {\n    size: 12,\n    accessor: d => d,\n  };\n  render() {\n    if (this.props.data === null) {\n      return null;\n    }\n    const { accessor, data, size } = this.props;\n    return (\n      <div>\n        {data.map((row, index) => (\n          <FlexRow key={`r-${index}`} styles={{ height: size }}>\n            {row.map((cell, index) => (\n              <FlexColumn\n                key={`c-${index}`}\n                styles={{\n                  width: size,\n                  overflow: 'hidden',\n                  alignItems: 'center',\n                  justifyContent: 'center',\n                  // border: \"1px solid black\"\n                }}\n              >\n                <div\n                  style={{\n                    background: '#000',\n                    borderRadius: accessor(cell) ? 0 : '50%',\n                    width: accessor(cell) ? '100%' : 0,\n                    height: accessor(cell) ? '100%' : 0,\n                    // transition: \"all 0.1s\"\n                  }}\n                ></div>\n              </FlexColumn>\n            ))}\n          </FlexRow>\n        ))}\n      </div>\n    );\n  }\n}\n\nconst Frame = ({ data, size = 12, initData }) => {\n  if (data === null) {\n    return null;\n  }\n  return (\n    <div>\n      {data.map((row, index) => (\n        <div\n          key={`r-${index}`}\n          style={{ display: 'flex', flexDirection: 'row', height: size }}\n        >\n          {row.map((cell, index) => (\n            <div\n              key={`c-${index}`}\n              style={{\n                width: size,\n                background: cell ? '#000' : 'none',\n              }}\n            />\n          ))}\n        </div>\n      ))}\n    </div>\n  );\n};\n\nconst GameOfLife = () => (\n  <Model\n    auto={false}\n    controls={{\n      param: 'density',\n      maxValue: 1,\n      step: 0.01,\n      resetOnChange: true,\n      label: 'Grid density',\n    }}\n    showTimeSlider={false}\n    updateData={updateGameOfLifeGrid}\n    delay={100}\n    initData={initGrid}\n    initialParams={{\n      height: 24,\n      width: 48,\n      density: 0.15,\n    }}\n  >\n    <Frame />\n  </Model>\n);\n\nexport const Step2 = () => (\n  <Model\n    initData={initGrid}\n    initialParams={{\n      height: 24,\n      width: 48,\n      density: 0.15,\n    }}\n  >\n    <Frame />\n  </Model>\n);\n\nexport const Step3 = () => (\n  <Model\n    initData={initGrid}\n    updateData={updateGridNoComplete}\n    initialParams={{\n      height: 24,\n      width: 48,\n      density: 0.15,\n    }}\n  >\n    <Frame />\n  </Model>\n);\n\nexport const Step4 = () => (\n  <Model\n    initData={initGrid}\n    updateData={updateGameOfLifeGrid}\n    initialParams={{\n      height: 24,\n      width: 48,\n      density: 0.15,\n    }}\n  >\n    <Frame />\n  </Model>\n);\n\nexport const Step5 = () => (\n  <Model\n    controls={{\n      param: 'density',\n      resetOnChange: true,\n      maxValue: 1,\n      step: 0.01,\n      label: 'Grid density',\n    }}\n    showTimeSlider={false}\n    initData={initGrid}\n    updateData={updateGameOfLifeGrid}\n    initialParams={{\n      height: 24,\n      width: 48,\n      density: 0.15,\n    }}\n  >\n    <Frame />\n  </Model>\n);\n\nexport default GameOfLife;\n","import * as React from 'react'\n  /* @jsx mdx */\nimport { mdx } from '@mdx-js/react';\n/* @jsx mdx */\n\nimport GameOfLife, { Step2, Step3, Step4, Step5 } from '../components/examples/game-of-life';\nexport const _frontmatter = {\n  \"Title\": \"Tutorial\"\n};\n\nconst makeShortcode = name => function MDXDefaultShortcode(props) {\n  console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n  return <div {...props} />;\n};\n\nconst layoutProps = {\n  _frontmatter\n};\nconst MDXLayout = \"wrapper\";\nexport default function MDXContent({\n  components,\n  ...props\n}) {\n  return <MDXLayout {...layoutProps} {...props} components={components} mdxType=\"MDXLayout\">\n\n    <p>{`To illustrate how React-Sim works, let's recreate John Conway's game of life.`}</p>\n    <p>{`Our finished demo:`}</p>\n    <GameOfLife mdxType=\"GameOfLife\" />\n    <h1>{`Setup`}</h1>\n    <p>{`This assumes you have a running React project. If not, check out `}<a parentName=\"p\" {...{\n        \"href\": \"http://create-react-app.dev\"\n      }}>{`create-react-app`}</a>{`.`}</p>\n    <p>{`In your project, install react-sim:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-bash\"\n      }}>{`npm install react-sim\n`}</code></pre>\n    <p>{`And start a new file.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-jsx\"\n      }}>{`import React from 'react';\nimport {Model} from 'react-sim';\n\nconst GameOfLife = () => <Model />;\n\nexport default GameOfLife;\n`}</code></pre>\n    <p>{`You'll have a very simple model up and running, but that is not game of life.`}</p>\n    <p>{`To get our simulation started, we need:`}</p>\n    <ul>\n      <li parentName=\"ul\">{`a way to initialize the data,`}</li>\n      <li parentName=\"ul\">{`a way to update data after each tick,`}</li>\n      <li parentName=\"ul\">{`a way to render the data, and`}</li>\n      <li parentName=\"ul\">{`controls.`}</li>\n    </ul>\n    <p>{`Let's build all this!`}</p>\n    <h1>{`initialize the data`}</h1>\n    <p>{`Now, we're going to add a function to initialize our data.\nThe data will look like a 2d grid with random 0s or 1s, corresponding to whether a cell is full or not.\nSo, to initiate our grid, we need to know its dimensions, and we can also control how full our grid is going to be.\nSo, we'll give three arguments to this function: height, width and density.\nHeight and width will be integers, the number of cells in each dimension, and density will be a value between 0 and 1.\nThe lower density is, the emptier the grid will be.`}</p>\n    <p>{`Add a function:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-jsx\"\n      }}>{`function initGrid({ height, width, density }) {\n  return Array(height)\n    .fill(0)\n    .map(row =>\n      Array(width)\n        .fill(0)\n        .map(() => Number(Math.random()) < density)\n    );\n}\n`}</code></pre>\n    <p>{`The arguments to initGrid should come from the model's params.`}</p>\n    <p>{`So let's change `}<inlineCode parentName=\"p\">{`const GameOfLife = () => <Model />;`}</inlineCode>{` into:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-jsx\"\n      }}>{`const GameOfLife = () => (\n  <Model\n    initialParams={{\n      height: 24,\n      width: 48,\n      density: 0.15\n    }}\n    initData={initGrid}\n  />\n)\n`}</code></pre>\n    <p>{`Now, when the simulation will start, data will be updated to a random grid.`}</p>\n    <h1>{`Rendering the data`}</h1>\n    <p>{`Let's create a Frame component to render our data.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-jsx\"\n      }}>{`const Frame = ({ data = [[]], size = 12, initData }) => (\n  <div>\n    {data.map((row, index) => (\n      <div\n        key={\\`r-\\${index}\\`}\n        styles={{ display: 'flex', flexDirection: 'row', height: size }}\n      >\n        {row.map((cell, index) => (\n          <div\n            key={\\`c-\\${index}\\`}\n            style={{\n              width: size,\n              background: cell ? '#000' : 'none',\n            }}\n          />\n        ))}\n      </div>\n    ))}\n    <div\n      style={{\n        cursor: 'pointer',\n        background: '#eee',\n        padding: '8px',\n        margin: '8px 8px 8px 0',\n        width: 'fit-content',\n      }}\n      onClick={initData}\n    >\n      Reset grid\n    </div>\n  </div>\n);\n`}</code></pre>\n    <p>{`Now, let's update our model:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-jsx\"\n      }}>{`const GameOfLife = () => (\n  <Model\n    initialParams={{\n      height: 24,\n      width: 48,\n      density: 0.15\n    }}\n    initData={initGrid}\n  >\n    <Frame />\n  </Model>\n)\n`}</code></pre>\n    <p>{`Nothing super unusual, we literally display a black square if a cell is full and nothing if it isn't.\nWe add a little Reset button at the end so users can reset the data.`}</p>\n    <Step2 mdxType=\"Step2\" />\n    <p>{`That's what we have at this point. Now we can display our random grid, but it doesn't change as the simulation plays, because we're not updating the data. Let's fix that.`}</p>\n    <h1>{`Updating data`}</h1>\n    <p>{`Next, we're going to create a function that updates our data.`}</p>\n    <p>{`The rules of the game of life is that after each turn:`}</p>\n    <ul>\n      <li parentName=\"ul\">{`Any live cell with 2 or 3 live neighbors survive.`}</li>\n      <li parentName=\"ul\">{`Any dead cell with three live neighbors becomes a live cell.`}</li>\n      <li parentName=\"ul\">{`All other live cells die in the next generation. Similarly, all other dead cells stay dead.`}</li>\n    </ul>\n    <p>{`So, first we need a way to count neighbors of a cell. Let's add this helper function:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-jsx\"\n      }}>{`function countNeighbors(x, y, grid) {\n  const height = grid.length;\n  if (!height) {\n    return 0;\n  }\n  const width = grid[0].length;\n\n  let n = 0;\n  for (let xOffset = -1; xOffset <= 1; xOffset++) {\n    for (let yOffset = -1; yOffset <= 1; yOffset++) {\n      const x1 = x + xOffset;\n      const y1 = y + yOffset;\n      if (\n        x1 < width &&\n        x1 > 0 &&\n        y1 < height &&\n        y1 > 0 &&\n        (x1 !== x || y1 !== y)\n      ) {\n        n += grid[y1][x1];\n      }\n    }\n  }\n  return n;\n}\n`}</code></pre>\n    <p>{`And now, let's create our update function:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-jsx\"\n      }}>{`function updateGrid({ data }) {\n  return data.map((row, y) =>\n    row.map((cell, x) => {\n      const neighbors = countNeighbors(x, y, data);\n      if (cell && (neighbors < 2 || neighbors > 3)) {\n        // living cell has too few or too many neighbors, and dies.\n        return 0;\n      }\n      if (!cell && neighbors === 3) {\n        // dead cell has the right amount of neighbors, and lives!\n        return 1;\n      }\n      // no change\n      return cell;\n    })\n  );\n}\n`}</code></pre>\n    <p>{`Finally, let's plug our update function in our model:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-jsx\"\n      }}>{`const GameOfLife = () => (\n  <Model\n    initialParams={{\n      height: 24,\n      width: 48,\n      density: 0.15\n    }}\n    initData={initGrid}\n    updateData={updateGrid}\n  >\n    <Frame />\n  </Model>\n)\n`}</code></pre>\n    <Step3 mdxType=\"Step3\" />\n    <p>{`Now, our game of life updates as the simulation plays!`}</p>\n    <p>{`There is a problem though - if the data reaches a stable state, ie no new cell live or die, the simulation continues. It would be nice if it stopped in this case.`}</p>\n    <p>{`Let's change our update function -`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-jsx\"\n      }}>{`function updateGrid({ data, complete }) {\n  let changes = 0;\n  const updatedGrid = data.map((row, y) =>\n    row.map((cell, x) => {\n      const neighbors = countNeighbors(x, y, data);\n      if (cell && (neighbors < 2 || neighbors > 3)) {\n        // living cell has too few or too many neighbors, and dies.\n        changes++;\n        return 0;\n      }\n      if (!cell && neighbors === 3) {\n        // dead cell has the right amount of neighbors, and lives!\n        changes++;\n        return 1;\n      }\n      // no change\n      return cell;\n    })\n  );\n  if (changes === 0) {\n    complete();\n  }\n  return updatedGrid;\n}\n`}</code></pre>\n    <p>{`In your update function, you can access the method `}<inlineCode parentName=\"p\">{`complete()`}</inlineCode>{`, and so define conditions in this function that will call this method.\nWhen `}<inlineCode parentName=\"p\">{`complete()`}</inlineCode>{` is called, the simulation stops, until it is reset.`}</p>\n    <Step4 mdxType=\"Step4\" />\n    <p>{`Now our simulation will stop if it can't go any further.`}</p>\n    <h1>{`Controls`}</h1>\n    <p>{`Right now, the simulation has default controls, which is the `}<inlineCode parentName=\"p\">{`Timer`}</inlineCode>{` slider.\nWe can see time, we can move the slider back and forth. This will take us back to previous states of the simulation, or take us many steps in the future.`}</p>\n    <p>{`But let's get rid of the slider for now.\nOn the other hand, it would be nice if we could adjust the density of the grid.`}</p>\n    <p>{`So let's address these two things.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-jsx\"\n      }}>{`const GameOfLife = () => (\n  <Model\n    showTimeSlider={false}\n    controls={{\n      param: 'density',\n      maxValue: 1,\n      step: 0.01,\n      label: 'Grid density',\n      resetOnChange: true,\n    }}\n    initData={initGrid}\n    updateData={updateGameOfLifeGrid}\n    initialParams={{\n      height: 24,\n      width: 48,\n      density: 0.15,\n    }}\n  >\n    <Frame />\n  </Model>);\n`}</code></pre>\n    <p>{`We can hide the time slider by setting `}<inlineCode parentName=\"p\">{`showTimeSlider`}</inlineCode>{` to false.`}</p>\n    <p>{`We're adding a control via the `}<inlineCode parentName=\"p\">{`controls`}</inlineCode>{` prop. Here we have only one control, so we can use this simple syntax of just passing one object describing the control, with:`}</p>\n    <ul>\n      <li parentName=\"ul\">{`the param it's going to affect (\"density\"),`}</li>\n      <li parentName=\"ul\">{`its maxValue, if different from the default of 100,`}</li>\n      <li parentName=\"ul\">{`its step, if different from the default of 1,`}</li>\n      <li parentName=\"ul\">{`a label, which is the name of the param, by default.`}</li>\n      <li parentName=\"ul\">{`resetOnChange: we want the simulation to reinitialize if we touch that control.`}</li>\n    </ul>\n    <p>{`That's it! we now can control the density of the grid.`}</p>\n    <Step5 mdxType=\"Step5\" />\n    <h1>{`Wrapping up`}</h1>\n    <p>{`The simulation is still super fast, as it refreshes 60 times per second. We can't see patterns so well.\nWe can add a delay between each animation tick - through the delay property.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-jsx\"\n      }}>{`const GameOfLife = () => (\n  <Model\n    delay={100}\n    showTimeSlider={false}\n    controls={{\n      param: 'density',\n      maxValue: 1,\n      step: 0.01,\n      label: 'Grid density',\n      resetOnChange: true,\n    }}\n    initData={initGrid}\n    updateData={updateGameOfLifeGrid}\n    initialParams={{\n      height: 24,\n      width: 48,\n      density: 0.15,\n    }}\n  >\n    <Frame />\n  </Model>);\n`}</code></pre>\n    <p>{`And that concludes our tutorial!`}</p>\n    <GameOfLife mdxType=\"GameOfLife\" />\n\n    </MDXLayout>;\n}\n;\nMDXContent.isMDXComponent = true;\n      "],"sourceRoot":""}