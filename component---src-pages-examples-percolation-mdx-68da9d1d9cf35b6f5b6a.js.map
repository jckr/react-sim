{"version":3,"sources":["webpack:///./src/components/examples/percolation.js","webpack:///./src/pages/examples/percolation.mdx"],"names":["Model","props","sx","border","p","width","status","updateData","data","params","complete","queue","grid","height","updatedStatus","length","nextQueue","cell","shift","x","y","push","shouldComplete","updateDataGrid","nbPending","grids","forEach","row","updatedCell","cols","result","initData","porosity","Math","random","Number","PercolationFrame","cellSize","margin","canvasRef","useRef","useEffect","ctx","current","getContext","fillStyle","fillRect","rowIndex","colIndex","r","tl","tr","br","topLeft","topRight","bottomLeft","bl","bottomRight","beginPath","moveTo","lineTo","quadraticCurveTo","closePath","roundRect","fill","lineWidth","strokeStyle","lineCap","max","stroke","style","boxSizing","ref","PercolationFrameGrid","ch","cw","display","flexDirection","rows","map","c","fontSize","textAlign","fontWeight","m","toFixed","key","total","Percolation","auto","controls","param","label","minValue","maxValue","step","maxTime","Infinity","initialParams","initDataGrid","minP","stepP","ck","Array","keys","PercolationGrid","_frontmatter","layoutProps","MDXContent","components","mdxType","parentName","isMDXComponent"],"mappings":"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","file":"component---src-pages-examples-percolation-mdx-68da9d1d9cf35b6f5b6a.js","sourcesContent":["import React, { useRef, useEffect } from 'react';\nimport { Flex, Box } from 'rebass';\nimport { Model as RawModel } from 'react-sim';\n\nconst Model = props => (\n  <Flex sx={{ border: '1px solid #000', p: 2, width: 'fit-content' }}>\n    <RawModel {...props} />\n  </Flex>\n);\n\nconst EMPTY = 0;\nconst ROCK = 1;\nconst ROCK_WITH_ROCK_ON_RIGHT = 2;\nconst ROCK_WITH_ROCK_BELOW = 3;\nconst ROCK_WITH_ROCK_RIGHT_AND_BELOW = 4;\nconst ROCK_WITH_ROCKS_ALL_AROUND = 5;\nconst WATER_FROM_TOP = 6;\nconst WATER_FROM_RIGHT = 7;\nconst WATER_FROM_LEFT = 8;\n\nconst status = {\n  pending: 'PENDING',\n  success: 'SUCCESS',\n  failure: 'FAILURE',\n};\n\nfunction updateData({ data, params, complete }) {\n  const { queue, grid } = data;\n  const { height, width } = params;\n  let updatedStatus = data.status;\n  if (queue.length === 0) {\n    updatedStatus = status.failure;\n  }\n  const nextQueue = [];\n  while (queue.length > 0 && updatedStatus === status.pending) {\n    const cell = queue.shift();\n    const { x, y } = cell;\n    if (y === height - 1) {\n      updatedStatus = status.success;\n    } else if (grid[y + 1][x] === EMPTY) {\n      grid[y + 1][x] = WATER_FROM_TOP;\n      nextQueue.push({ x, y: y + 1 });\n    }\n    // note - grid[y][x - 1] and grid[y][x + 1] can be undefined,\n    // but that doesn't make any difference.\n    if (grid[y][x - 1] === EMPTY) {\n      grid[y][x - 1] = WATER_FROM_RIGHT;\n      nextQueue.push({ x: x - 1, y });\n    }\n    if (grid[y][x + 1] === EMPTY) {\n      grid[y][x + 1] = WATER_FROM_LEFT;\n      nextQueue.push({ x: x + 1, y });\n    }\n  }\n  if (updatedStatus !== status.pending && params.shouldComplete) {\n    complete(updatedStatus);\n  }\n  return {\n    grid,\n    queue: nextQueue,\n    status: updatedStatus,\n  };\n}\n\nfunction updateDataGrid({ data, params, complete }) {\n  let nbPending = 0;\n  data.grids.forEach((row, y) =>\n    row.forEach((cell, x) => {\n      if (cell.status === status.pending) {\n        const updatedCell = updateData({\n          data: cell,\n          params: { height: params.height, shouldComplete: false },\n        });\n        data.grids[y][x] = updatedCell;\n        if (updatedCell.status === status.pending) {\n          nbPending++;\n        }\n        if (updatedCell.status === status.success) {\n          data.cols[x].result++;\n        }\n      }\n    })\n  );\n  if (nbPending === 0) {\n    complete();\n  }\n  return data;\n}\n\nfunction initData({ porosity, height, width }) {\n  const grid = [];\n  const queue = [];\n  let x, y;\n  for (y = 0; y < height; y++) {\n    const row = [];\n    for (x = 0; x < width; x++) {\n      row.push(Math.random() > Number(porosity) ? ROCK : EMPTY);\n    }\n    grid.push(row);\n  }\n\n  for (y = 0; y < height; y++) {\n    for (x = 0; x < width; x++) {\n      if (grid[y][x]) {\n        if (grid[y + 1] && grid[y + 1][x]) {\n          // rock below\n          grid[y][x] = grid[y][x] + 2;\n        }\n        if (grid[y][x + 1]) {\n          // rock to the right\n          grid[y][x] = grid[y][x] + 1;\n        }\n        if (\n          grid[y][x] === ROCK_WITH_ROCK_RIGHT_AND_BELOW &&\n          grid[y + 1][x + 1]\n        ) {\n          grid[y][x] = ROCK_WITH_ROCKS_ALL_AROUND;\n        }\n      } else {\n        if (y === 0) {\n          grid[y][x] = WATER_FROM_TOP;\n          queue.push({ x, y });\n        }\n      }\n    }\n  }\n  return { grid, queue, status: status.pending };\n}\n\nfunction roundRect({ ctx, x, y, width, height, r = 1, tl, tr, br, bl }) {\n  const topLeft = tl || r;\n  const topRight = tr || r;\n  const bottomLeft = bl || r;\n  const bottomRight = br || r;\n\n  ctx.beginPath();\n  ctx.moveTo(x + topLeft, y);\n  ctx.lineTo(x + width - topRight, y);\n  ctx.quadraticCurveTo(x + width, y, x + width, y + topRight);\n  ctx.lineTo(x + width, y + height - bottomRight);\n  ctx.quadraticCurveTo(\n    x + width,\n    y + height,\n    x + width - bottomRight,\n    y + height\n  );\n  ctx.lineTo(x + bottomLeft, y + height);\n  ctx.quadraticCurveTo(x, y + height, x, y + height - bottomLeft);\n  ctx.lineTo(x, y + topLeft);\n  ctx.quadraticCurveTo(x, y, x + topLeft, y);\n  ctx.closePath();\n}\n\nconst PercolationFrame = ({ data, params }) => {\n  const { cellSize, margin, height, width } = params;\n  const canvasRef = useRef(null);\n  useEffect(() => {\n    const canvas = canvasRef.current;\n    const ctx = canvas.getContext('2d');\n    ctx.fillStyle = 'beige';\n    ctx.fillRect(0, 0, width * cellSize, height * cellSize);\n\n    if (data === null) {\n      return;\n    }\n\n    data.grid.forEach((row, rowIndex) => {\n      row.forEach((cell, colIndex) => {\n        const x = colIndex * cellSize;\n        const y = rowIndex * cellSize;\n        if (cell >= ROCK && cell <= ROCK_WITH_ROCKS_ALL_AROUND) {\n          // rock\n          ctx.fillStyle = '#777';\n\n          roundRect({\n            ctx,\n            x: x + margin,\n            y: y + margin,\n            r: margin,\n            height: cellSize - 2 * margin,\n            width: cellSize - 2 * margin,\n          });\n          ctx.fill();\n          if (\n            cell === ROCK_WITH_ROCK_ON_RIGHT ||\n            cell === ROCK_WITH_ROCK_RIGHT_AND_BELOW ||\n            cell === ROCK_WITH_ROCKS_ALL_AROUND\n          ) {\n            ctx.fillRect(\n              x + cellSize - 2 * margin,\n              y + margin,\n              4 * margin,\n              cellSize - 2 * margin\n            );\n          }\n          if (\n            cell === ROCK_WITH_ROCK_BELOW ||\n            cell === ROCK_WITH_ROCK_RIGHT_AND_BELOW ||\n            cell === ROCK_WITH_ROCKS_ALL_AROUND\n          ) {\n            ctx.fillRect(\n              x + margin,\n              y + cellSize - 2 * margin,\n              cellSize - 2 * margin,\n              4 * margin\n            );\n          }\n          if (cell === ROCK_WITH_ROCKS_ALL_AROUND) {\n            ctx.fillRect(\n              x + cellSize - 2 * margin,\n              y + cellSize - 2 * margin,\n              4 * margin,\n              4 * margin\n            );\n          }\n        }\n        if (cell >= WATER_FROM_TOP) {\n          ctx.lineWidth = cellSize - 2 * margin;\n          ctx.strokeStyle = 'cyan';\n          ctx.lineCap = 'round';\n          ctx.beginPath();\n          ctx.moveTo(x + cellSize / 2, y + cellSize / 2);\n          if (cell === WATER_FROM_TOP) {\n            ctx.lineTo(x + cellSize / 2, Math.max(y - cellSize / 2, 0));\n          }\n          if (cell === WATER_FROM_LEFT) {\n            ctx.lineTo(x - cellSize / 2, y + cellSize / 2);\n          }\n          if (cell === WATER_FROM_RIGHT) {\n            ctx.lineTo(x + (3 * cellSize) / 2, y + cellSize / 2);\n          }\n          ctx.stroke();\n        }\n      });\n    });\n  });\n\n  return (\n    <div\n      style={{\n        boxSizing: 'content-box',\n        height: cellSize * height,\n        width: cellSize * width,\n        border: `3px solid ${\n          data.status === status.pending\n            ? 'transparent'\n            : data.status === status.success\n            ? '#33e'\n            : '#777'\n        }`,\n      }}\n    >\n      <canvas\n        width={width * cellSize}\n        height={height * cellSize}\n        ref={canvasRef}\n      />\n    </div>\n  );\n};\n\nconst PercolationFrameGrid = ({ data, params }) => {\n  const ch = params.height * params.cellSize;\n  const cw = params.width * params.cellSize;\n\n  return (\n    <div\n      style={{\n        display: 'flex',\n        flexDirection: 'column',\n        height: (ch + 10) * params.rows + 60,\n        width: (cw + 10) * params.cols + 10,\n      }}\n    >\n      <Flex flexDirection=\"row\">\n        {data.cols.map(c => (\n          <Box\n            sx={{\n              width: [cw],\n              fontSize: 1,\n              textAlign: 'center',\n              fontWeight: 2,\n              m: '5px',\n            }}\n          >\n            {c.p.toFixed(2)}\n          </Box>\n        ))}\n      </Flex>\n      {data.grids.map((row, y) => (\n        <div style={{ display: 'flex', flexDirection: 'row' }} key={`row-${y}`}>\n          {row.map((cell, x) => (\n            <div\n              style={{\n                height: params.height * params.cellSize,\n                width: params.width * params.cellSize,\n                margin: 5,\n              }}\n            >\n              <PercolationFrame\n                key={`cell-${x}-${y}`}\n                data={cell}\n                params={params}\n              />\n            </div>\n          ))}\n        </div>\n      ))}\n      <Flex flexDirection=\"row\">\n        {data.cols.map(c => (\n          <Box\n            sx={{\n              width: [cw],\n              fontSize: 1,\n              textAlign: 'center',\n              m: '5px',\n            }}\n          >\n            {`${c.result}/${c.total}`}\n          </Box>\n        ))}\n      </Flex>\n    </div>\n  );\n};\n\nexport const Percolation = () => {\n  return (\n    <>\n      <Model\n        auto={false}\n        controls={{\n          param: 'porosity',\n          label: 'Porosity',\n          minValue: 0,\n          maxValue: 1,\n          step: 0.01,\n        }}\n        updateData={updateData}\n        maxTime={Infinity}\n        initData={initData}\n        initialParams={{\n          width: 100,\n          height: 100,\n          cellSize: 5,\n          margin: 0,\n          porosity: 0.6,\n          shouldComplete: true,\n        }}\n      >\n        <PercolationFrame />\n      </Model>\n    </>\n  );\n};\n\nfunction initDataGrid({\n  width,\n  height,\n  cellSize,\n  margin,\n  rows,\n  cols,\n  minP,\n  stepP,\n}) {\n  const ck = [...Array(cols).keys()];\n  return {\n    cols: ck.map(c => ({ p: minP + c * stepP, result: 0, total: rows })),\n    grids: [...Array(rows).keys()].map(r =>\n      ck.map(c =>\n        initData({\n          height,\n          width,\n          porosity: minP + c * stepP,\n        })\n      )\n    ),\n  };\n}\n\nexport const PercolationGrid = () => {\n  return (\n    <>\n      <Model\n        auto={false}\n        updateData={updateDataGrid}\n        maxTime={Infinity}\n        initData={initDataGrid}\n        initialParams={{\n          width: 20,\n          height: 20,\n          cellSize: 1.5,\n          margin: 0,\n          rows: 10,\n          cols: 10,\n          minP: 0.5,\n          stepP: 0.02,\n        }}\n      >\n        <PercolationFrameGrid />\n      </Model>\n    </>\n  );\n};\n","import * as React from 'react'\n  /* @jsx mdx */\nimport { mdx } from '@mdx-js/react';\n/* @jsx mdx */\n\nimport { Percolation, PercolationGrid } from '../../components/examples/percolation';\nexport const _frontmatter = {\n  \"Title\": \"Percolation\"\n};\n\nconst makeShortcode = name => function MDXDefaultShortcode(props) {\n  console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n  return <div {...props} />;\n};\n\nconst layoutProps = {\n  _frontmatter\n};\nconst MDXLayout = \"wrapper\";\nexport default function MDXContent({\n  components,\n  ...props\n}) {\n  return <MDXLayout {...layoutProps} {...props} components={components} mdxType=\"MDXLayout\">\n\n    <h1>{`Percolation`}</h1>\n    <p>{`A 2D lattice is made of cells which either let liquid go through (porous) or not.\nIf we pour liquid on the top of the lattice, will any of it go through? This depends on the porosity of the lattice, i.e. the percentage of cells which are porous.`}</p>\n    <Percolation mdxType=\"Percolation\" />\n    <p>{`Interestingly, the chances of liquid getting through don't vary linearly with the porosity. If porosity is beyond a certain `}<a parentName=\"p\" {...{\n        \"href\": \"https://en.wikipedia.org/wiki/Percolation_threshold\"\n      }}>{`threshold`}</a>{`, there are very little chances that the liquid gets through, and beyond that threshold it becomes very likely.\nFor our 2D lattice with liquid being able to go in all 4 directions, the threshold is around `}<em parentName=\"p\">{`0.59`}</em>{`.`}</p>\n    <p>{`To see how dramatically the chances of liquid percolating increase once we're past the threshold, let's simulate 100 pours at a time:\nOn that grid, every column has the same porosity index.`}</p>\n    <PercolationGrid mdxType=\"PercolationGrid\" />\n\n    </MDXLayout>;\n}\n;\nMDXContent.isMDXComponent = true;\n      "],"sourceRoot":""}