(window.webpackJsonp=window.webpackJsonp||[]).push([[52],{fO4F:function(e,a,t){"use strict";t.r(a),t.d(a,"_frontmatter",(function(){return s})),t.d(a,"default",(function(){return l}));var n=t("zLVn"),r=(t("q1tI"),t("7ljp")),o=t("TVkH"),i=["components"],s={Title:"Maze generation"},c={_frontmatter:s};function l(e){var a=e.components,t=Object(n.a)(e,i);return Object(r.b)("wrapper",Object.assign({},c,t,{components:a,mdxType:"MDXLayout"}),Object(r.b)("h1",{id:"maze-generation"},"Maze generation"),Object(r.b)(o.k,{isPlaying:!0,controls:null,mdxType:"Maze"}),Object(r.b)("p",null,"A ",Object(r.b)("strong",{parentName:"p"},"perfect maze")," is a diagram where ",Object(r.b)("em",{parentName:"p"},"cells")," can be linked with ",Object(r.b)("em",{parentName:"p"},"paths"),", and there is a unique path between any two cells.\nSo, if you pick 2 cells in the maze, for instance opposite corners, there is one and only one way to go from one to the other."),Object(r.b)("p",null,"The data structure of a maze is really a graph with node and links, and more precisely, a spanning tree.\nTo create our mazes, we start from a graph where each cell is a node, linked to its neighbors."),Object(r.b)("p",null,"In the example above, each cell has neighbors to the top, right, below and left, unless it sits on an edge.\nIn the ",Object(r.b)("em",{parentName:"p"},"data initialization")," part of our model, we create that grid and list all potential neighbors for every cell."),Object(r.b)("p",null,"Then, we're going to connect these cells.\nWe start with one arbitrary cell, which we mark as visited. Then, we check which of its neighbors is not visited, we randomly choose one, and we create a link between these two cells.\nNext, we'll look at the neighbors of the new cell, randomly pick one, and proceed, until we can't go any further - all neighbors are visited. Then, we backtrack until we find a cell with unvisited neighbors. We pick one at random, continue until we can't, then backtrack.\nAt each step of this process, we are going to create one extra path between two neighboring cells.\nSo, at each tick, we can ",Object(r.b)("em",{parentName:"p"},"update our data")," and have one extra connection."),Object(r.b)("p",null,"We stop when every cell is visited."),Object(r.b)("p",null,"Rendering a square maze is pretty straighforward, we can draw a grid and just draw short lines across 2 cells to represent a path."),Object(r.b)("h2",{id:"non-square-mazes"},"Non-square mazes"),Object(r.b)(o.k,{mdxType:"Maze"}),Object(r.b)("p",null,"Creating a maze is really creating a tree from a strongly connected graph. The result doesn't have to look like a square."),Object(r.b)("p",null,'Our maze generator can work with a few other shapes. We can have an hexagonal grid, where each cell can have up to 6 neighbors, or a triangular one, where each cell has up to 3.\nWe\'ve also added a circular "grid" - concentric circles divided into segments. Each segment has neighbors on the same layer, but may also have neighbors on other layers.'),Object(r.b)("h2",{id:"other-maze-algorithms"},"Other maze algorithms"),Object(r.b)("p",null,"Here, we've used a simple DFS approach to parse our graph. There are ",Object(r.b)("a",{parentName:"p",href:"https://www.astrolog.org/labyrnth/algrithm.htm"},"many other ways")," to turn a graph into a maze!"))}l.isMDXComponent=!0}}]);
//# sourceMappingURL=component---src-pages-examples-mazes-mdx-1dece8a038b86ad26075.js.map