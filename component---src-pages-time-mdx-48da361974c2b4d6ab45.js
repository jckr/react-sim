(window.webpackJsonp=window.webpackJsonp||[]).push([[69],{"jTN+":function(e,t,a){"use strict";a.r(t),a.d(t,"_frontmatter",(function(){return o})),a.d(t,"default",(function(){return c}));var n=a("zLVn"),i=(a("q1tI"),a("7ljp")),l=a("u0c3"),r=["components"],o={Title:"Time"},b={_frontmatter:o};function c(e){var t=e.components,a=Object(n.a)(e,r);return Object(i.b)("wrapper",Object.assign({},b,a,{components:t,mdxType:"MDXLayout"}),Object(i.b)("h1",{id:"how-time-works"},"How Time Works"),Object(i.b)("p",null,"Time is one of the central notions of ",Object(i.b)("inlineCode",{parentName:"p"},"react-sim"),"."),Object(i.b)("p",null,"A react-sim ",Object(i.b)("inlineCode",{parentName:"p"},"Model")," will maintain:"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"tick")," (integer), a representation of the progress in the simulation,"),Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"data")," (anything), the internal state of the data to be shown,"),Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"isPlaying")," (boolean), a flag that controls whether the animation is running or not.")),Object(i.b)("p",null,"In addition to these main properties, ",Object(i.b)("inlineCode",{parentName:"p"},"Model")," also maintains:"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"cachedData")," (object), which caches data which has already been calculated for a given ",Object(i.b)("inlineCode",{parentName:"li"},"tick"),","),Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"results")," (array), where information on the previous runs of the simulation can be stored.")),Object(i.b)("p",null,"The simulation author is expected to pass properties such as:"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"initialParams")," (object), a list of params for the simulation. They can be overridden by the ",Object(i.b)("a",{parentName:"li",href:"/react-sim/controls"},"controls"),"."),Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"initData")," (function), which takes ",Object(i.b)("inlineCode",{parentName:"li"},"params"),"as input and outputs the first value for ",Object(i.b)("inlineCode",{parentName:"li"},"data"),"."),Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"updateData")," (function), which takes: ",Object(i.b)("inlineCode",{parentName:"li"},"params"),", ",Object(i.b)("inlineCode",{parentName:"li"},"data"),", ",Object(i.b)("inlineCode",{parentName:"li"},"tick"),", ",Object(i.b)("inlineCode",{parentName:"li"},"cachedData"),", and ",Object(i.b)("inlineCode",{parentName:"li"},"results")," as inputs, and outputs a new value for ",Object(i.b)("inlineCode",{parentName:"li"},"data"),".")),Object(i.b)("h1",{id:"the-simulation-lifecycle"},"The simulation lifecycle"),Object(i.b)("h2",{id:"initial-state"},"Initial state"),Object(i.b)("p",null,"When a ",Object(i.b)("inlineCode",{parentName:"p"},"<Model />")," is created it will:"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},"initiate the interal ",Object(i.b)("inlineCode",{parentName:"li"},"params")," from the values of ",Object(i.b)("inlineCode",{parentName:"li"},"initParams"),"."),Object(i.b)("li",{parentName:"ul"},"initiate ",Object(i.b)("inlineCode",{parentName:"li"},"tick")," - either through the ",Object(i.b)("inlineCode",{parentName:"li"},"minTime")," or the ",Object(i.b)("inlineCode",{parentName:"li"},"initialTick")," prop. ",Object(i.b)("inlineCode",{parentName:"li"},"minTime")," takes precedence."),Object(i.b)("li",{parentName:"ul"},"run ",Object(i.b)("inlineCode",{parentName:"li"},"initData")," and generate a first value for ",Object(i.b)("inlineCode",{parentName:"li"},"data")," from the ",Object(i.b)("inlineCode",{parentName:"li"},"params"),".")),Object(i.b)("p",null,"The ",Object(i.b)("a",{parentName:"p",href:"/react-sim/frame"},"frames")," will not render until ",Object(i.b)("inlineCode",{parentName:"p"},"initData")," has run, but they will render once ",Object(i.b)("inlineCode",{parentName:"p"},"data")," has been initialized once."),Object(i.b)("p",null,"If the ",Object(i.b)("inlineCode",{parentName:"p"},"isPlaying")," prop of the ",Object(i.b)("inlineCode",{parentName:"p"},"<Model />")," is set to true, it will start ",Object(i.b)("inlineCode",{parentName:"p"},"playing"),". Else, the simulation doesn't change until ",Object(i.b)("a",{parentName:"p",href:"/react-sim/controls"},"controls")," trigger it."),Object(i.b)("h2",{id:"playing"},"Playing"),Object(i.b)("p",null,"When the simulation is playing, every so often it will try to update ",Object(i.b)("inlineCode",{parentName:"p"},"data")," and refresh the ",Object(i.b)("inlineCode",{parentName:"p"},"Frames"),".\nBy default, the simulation refreshes 60 times per second."),Object(i.b)("p",null,"It's possible to make it go slower by providing a ",Object(i.b)("inlineCode",{parentName:"p"},"delay")," prop to ",Object(i.b)("inlineCode",{parentName:"p"},"Model"),". The simulation will wait that long (in ms) to refresh the animation.\nEach time the animation refreshes, the simulation will progress by 1 tick (i.e. the ",Object(i.b)("inlineCode",{parentName:"p"},"tick")," value will increase by 1.)\nIt's also possible to make it go faster with a ",Object(i.b)("inlineCode",{parentName:"p"},"ticksPerAnimation")," prop. If this value is greater than 1, then the simualtion will try to update ",Object(i.b)("inlineCode",{parentName:"p"},"data")," that many times before re-rendering ",Object(i.b)("inlineCode",{parentName:"p"},"Frames"),"."),Object(i.b)("p",null,"We can use both values at once. For instance, we can have a simulation that, every 100ms, updates 500 times."),Object(i.b)("h3",{id:"playing-stops-if"},"Playing stops if:"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},"the user ",Object(i.b)("em",{parentName:"li"},"pauses")," or ",Object(i.b)("em",{parentName:"li"},"stops")," the simulation,"),Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"ticks")," reaches the maximum value,"),Object(i.b)("li",{parentName:"ul"},"the simulation ",Object(i.b)("em",{parentName:"li"},"completes"),".")),Object(i.b)("p",null,"When the simulation ",Object(i.b)("em",{parentName:"p"},"pauses"),", ",Object(i.b)("inlineCode",{parentName:"p"},"isPlaying")," simply switches to false. Nothing else changes, ",Object(i.b)("inlineCode",{parentName:"p"},"tick")," stays the same, so does ",Object(i.b)("inlineCode",{parentName:"p"},"data"),", etc.\nThe ",Object(i.b)("a",{parentName:"p",href:"/react-sim/controls/default-timer"},"default timer")," provides an easy way for a user to trigger a ",Object(i.b)("inlineCode",{parentName:"p"},"pause"),". Model has an internal method that pauses, which can be exposed to controls."),Object(i.b)("p",null,"When the simulation ",Object(i.b)("em",{parentName:"p"},"stops"),", ",Object(i.b)("inlineCode",{parentName:"p"},"isPlaying")," switches to false, but data is also re-initiated:"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"tick")," goes back to its original value,"),Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"initData")," fires again and overwrites ",Object(i.b)("inlineCode",{parentName:"li"},"data"),","),Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"cachedData")," is emptied,"),Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"results")," is left unchanged.")),Object(i.b)("p",null,"The simulation ",Object(i.b)("em",{parentName:"p"},"completes")," when ",Object(i.b)("inlineCode",{parentName:"p"},"updateData")," triggered a condition where it can't go any further.\nWhen this happens:"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"isPlaying")," switches to false, but:"),Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"tick")," is unchanged,"),Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"data")," is unchanged,"),Object(i.b)("li",{parentName:"ul"},"A ",Object(i.b)("inlineCode",{parentName:"li"},"result")," for this run may be appended to ",Object(i.b)("inlineCode",{parentName:"li"},"results"),".")),Object(i.b)("p",null,"The simulation won't reset unless manually triggered."),Object(i.b)("h3",{id:"when-to-update-or-cache-data"},"When to update or cache data"),Object(i.b)("p",null,"Each time ",Object(i.b)("inlineCode",{parentName:"p"},"tick")," changes, ",Object(i.b)("inlineCode",{parentName:"p"},"data")," is updated.\nIf using cached data, and ",Object(i.b)("inlineCode",{parentName:"p"},"tick")," changes to a value for which ",Object(i.b)("inlineCode",{parentName:"p"},"cachedData")," has precomputed values, then the simulation will simply retrieve those values and not do further calculations.\nThis can happen, for instance, if a user uses the time slider to move back in time."),Object(i.b)("p",null,"Else, we're going to figure out which is the latest value of ",Object(i.b)("inlineCode",{parentName:"p"},"tick")," for which we have data, and through how many cycles do we have to go to get to the current value of ",Object(i.b)("inlineCode",{parentName:"p"},"tick")," - which can be just 1 if tick is simply incrementing along the animation, but which could be more if ",Object(i.b)("inlineCode",{parentName:"p"},"ticksPerAnimation")," is set, or if we are moving foward in time with the time slider, and run ",Object(i.b)("inlineCode",{parentName:"p"},"updateData")," as many times as needed.\n",Object(i.b)("inlineCode",{parentName:"p"},"updateData")," will stop running if:"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"tick")," reaches the maximum value, or"),Object(i.b)("li",{parentName:"ul"},"the simulation ",Object(i.b)("em",{parentName:"li"},"completes"),".")),Object(i.b)("p",null,"Each time it successfully runs, if caching data, it will update ",Object(i.b)("inlineCode",{parentName:"p"},"cachedData"),"."),Object(i.b)("p",null,"If a simulation is never going to complete, and has no maximum time value, and there's no reason to go back in time, then it may be a good idea to disable caching, as the system will eventually run out of memory. You can do that by setting the ",Object(i.b)("inlineCode",{parentName:"p"},"noCache")," property of the ",Object(i.b)("inlineCode",{parentName:"p"},"Model")," to ",Object(i.b)("inlineCode",{parentName:"p"},"true"),"."),Object(i.b)("h3",{id:"updating-data"},"Updating data"),Object(i.b)("p",null,"Updating data is done through the ",Object(i.b)("inlineCode",{parentName:"p"},"updateData")," function, which takes as arguments an object with the following properties:"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"data"),": the existing ",Object(i.b)("inlineCode",{parentName:"li"},"data"),","),Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"tick"),": the next value of ",Object(i.b)("inlineCode",{parentName:"li"},"tick"),","),Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"params"),": all the ",Object(i.b)("inlineCode",{parentName:"li"},"params")," of the simulation,"),Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"cachedData"),": the cached values of ",Object(i.b)("inlineCode",{parentName:"li"},"data")," for previous ticks,"),Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"results"),": the results of previous runs,"),Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"complete"),": a function that signals that the simulation is complete. If it's provided an argument (result), that is added to the ",Object(i.b)("inlineCode",{parentName:"li"},"results")," property of the simulation.")),Object(i.b)("p",null,Object(i.b)("inlineCode",{parentName:"p"},"updateData")," will return an updated value for ",Object(i.b)("inlineCode",{parentName:"p"},"data"),". Even if it completes, it's expected to return ",Object(i.b)("inlineCode",{parentName:"p"},"data"),"."),Object(i.b)("p",null,"The main idea behind ",Object(i.b)("inlineCode",{parentName:"p"},"updateData")," taking the existing ",Object(i.b)("inlineCode",{parentName:"p"},"data")," as an argument is that it can operates as a mathematical sequence."),Object(i.b)("p",null,"For example, in the following Fibonacci spiral example:"),Object(i.b)(l.b,{mdxType:"FibonacciSpiral"}),Object(i.b)("p",null,"the ",Object(i.b)("inlineCode",{parentName:"p"},"updateData")," function is a very simple recursion:"),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-jsx"},"function updateData({ data, tick }) {\n  if (tick === 0) {\n    return [0];\n  }\n  if (tick === 1) {\n    return [0, 1];\n  }\n  const lastNumber = data[tick - 1] + data[tick - 2];\n  return [...data, lastNumber];\n}\n")),Object(i.b)("p",null,"But ",Object(i.b)("inlineCode",{parentName:"p"},"updateData")," has access to other properties of the simulation, and can use past values of data, or even information on previous runs of the simulation, as needed.\n",Object(i.b)("inlineCode",{parentName:"p"},"updateData")," can also not use any of these arguments and provide values unrelated to the previous state of the simulation."))}c.isMDXComponent=!0},u0c3:function(e,t,a){"use strict";a.d(t,"b",(function(){return h})),a.d(t,"a",(function(){return O}));var n=a("KQm4"),i=a("q1tI"),l=a.n(i),r=a("1uUR"),o=a("VdAu"),b=a("sCKr"),c=.5+Math.sqrt(5)/2,s={0:"right",1:"down",2:"left",3:"up"};function p(){return[0]}function m(e){var t=e.data,a=e.tick;if(0===a)return[0];if(1===a)return[0,1];var i=t[a-1]+t[a-2];return[].concat(Object(n.a)(t),[i])}function u(e){var t=e.ctx,a=e.params.size,n=e.tick;t.fillStyle="#fff",t.fillRect(0,0,a,a);for(var i=0,l=0,r=a,o=0;o<n;o++){var b=s[o%4];r/=c,t.strokeStyle="#ddd",t.strokeRect(i,l,r,r),t.strokeStyle="#222";var p=Math.max(0,r-1);switch(b){case"right":t.beginPath(),t.arc(i+r,l+r,p,Math.PI,-Math.PI/2),t.stroke(),t.closePath(),i+=r;break;case"down":t.beginPath(),t.arc(i,l+r,p,-Math.PI/2,0),t.stroke(),t.closePath(),i+=(1-1/c)*r,l+=r;break;case"left":t.beginPath(),t.arc(i,l,p,0,Math.PI/2),t.stroke(),t.closePath(),i-=r/c,l+=(1-1/c)*r;break;case"up":t.beginPath(),t.arc(i+r,l,p,Math.PI/2,Math.PI),t.stroke(),t.closePath(),l-=r/c}}}var d=function(e){e.tick;var t=e.params.size,a=t,n=t/c;return l.a.createElement(r.a,{height:n,width:a,draw:u})},h=function(e){return l.a.createElement(b.a,Object.assign({initialParams:{size:332},delay:100,maxTime:15},e),l.a.createElement(d,null))},j=function(e){var t=e.data;return l.a.createElement(o.c,{sx:{flexDirection:"row",flexWrap:"wrap"}},t.map((function(e,t){return l.a.createElement(o.a,{sx:{m:1,p:2,bg:"muted",fontSize:1},key:t},e)})))},O=function(e){return l.a.createElement(b.a,Object.assign({initData:p,updateData:m,maxTime:20},e),l.a.createElement(j,null))};t.c=h}}]);
//# sourceMappingURL=component---src-pages-time-mdx-48da361974c2b4d6ab45.js.map