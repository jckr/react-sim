{"version":3,"sources":["webpack:///./src/components/examples/snake/helpers.js","webpack:///./src/components/examples/snake/index.js","webpack:///./src/pages/examples/snake.mdx"],"names":["DIRECTIONS","opposite","IS_VERTICAL","v","getDir","reduce","prev","curr","i","getRandomInBounds","min","max","Math","floor","random","isValid","x","y","visited","height","width","initVisited","grid","path","results","row","r","rowResults","cell","c","forEach","getLongestPath","start","end","length","stack","paths","next","found","node","shift","d","step","concat","push","getShortestPath","longestPath","lastInLongestPath","nextInStack","dx","dy","rightPoints","leftPoints","unshift","positionFruit","eligiblePositions","resultRow","updateSnake","data","params","complete","actionGrid","direction","head","fruit","fruitGrowth","isFull","updatedGrid","map","updatedHead","updatedDirection","updatedLength","updatedFruit","initSnake","initialLength","minY","maxY","xHead","yHead","j","tail","s","behindTail","frontOfSnake","undefined","getActionGrid","SnakeBit","size","color","directionNext","directionPrev","weight","ms","ws","style","position","borderRadius","background","left","top","bottom","right","goesUp","goesLeft","topleft","topright","bottomleft","bottomright","cornerStyles","overflow","ActionBit","action","boxSizing","border","transformOrigin","transform","SnakeFrame","renderAG","props","cellSize","className","key","renderSnake","display","alignItems","justifyContent","renderFruit","render","this","padding","React","Component","defaultProps","Snake","auto","maxTime","Infinity","initData","initialParams","updateData","_frontmatter","layoutProps","MDXContent","components","mdxType","isMDXComponent"],"mappings":"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","file":"component---src-pages-examples-snake-mdx-2c70712583e82f039355.js","sourcesContent":["// constants\n\nexport const UP = 0;\nexport const RIGHT = 1;\nexport const DOWN = 2;\nexport const LEFT = 3;\n\nexport const DIRECTIONS = [UP, RIGHT, DOWN, LEFT];\n\nexport const opposite = [DOWN, LEFT, UP, RIGHT];\nexport const IS_VERTICAL = [true, false, true, false];\nexport const IS_HORIZONTAL = [false, true, false, true];\n\nexport const v = [\n  [0, -1],\n  [1, 0],\n  [0, 1],\n  [-1, 0]\n];\n\nexport const getDir = v.reduce((prev, curr, i) => {\n  prev[curr] = i;\n  return prev;\n}, {});\n\n// helpers\n\nexport function getRandomInBounds(min, max) {\n  // returns a random integer within [min, max]\n  // (bounds are included)\n  return min + Math.floor(Math.random() * (max + 1 - min));\n}\n\nexport function isValid(x, y, visited, height, width) {\n  // returns whether one of the pathfinding functions can consider a cell\n  if (x < 0 || x > width - 1 || y < 0 || y > height - 1) {\n    return false;\n  }\n  if (visited[[x, y]]) {\n    return false;\n  }\n  return true;\n}\n\nexport function initVisited(grid = [[]], path = []) {\n  // refreshes the \"visited\" object\n  // every snake cell in the grid is marked as visited,\n  // every cell in the path as well.\n  // both are optional.\n\n  // because this is an object, it can be inadvertantly mutated\n  // so it's safer to reinitialize it after each use\n  const visited = grid.reduce(\n    (results, row, r) =>\n      row.reduce((rowResults, cell, c) => {\n        if (cell > 0) {\n          rowResults[[c, r]] = true;\n        }\n        return rowResults;\n      }, results),\n    {}\n  );\n  path.forEach(([r, c]) => (visited[[r, c]] = true));\n  return visited;\n}\n\nexport function getShortestPath({ grid, start, end }) {\n  // finds shortest path between start and end given status of a grid\n  // where visited cells can't be crossed\n\n  const height = grid.length;\n  if (height === 0) {\n    return [];\n  }\n  const width = grid[0].length;\n\n  const visited = initVisited(grid);\n  // paths - for each node, shortest path to reach that node from start\n  const paths = {};\n  const next = [start];\n  paths[start] = [start];\n  let found = false;\n  while (next.length && !found) {\n    const node = next.shift();\n    DIRECTIONS.forEach(d => {\n      // step is next node in that direction, from node\n      const step = [node[0] + v[d][0], node[1] + v[d][1]];\n      const [x, y] = step;\n      if (!isValid(x, y, visited, height, width)) {\n        return;\n      }\n      visited[step] = true;\n      paths[step] = paths[node].concat([step]);\n      if (x === end[0] && y === end[1]) {\n        found = true;\n      }\n      // we add each step to our queue. it's important to do BFS here\n      next.push(step);\n    });\n  }\n  // out shortest path\n  return paths[end];\n}\n\nexport function getLongestPath({ grid, start, end }) {\n  const height = grid.length;\n  if (height === 0) {\n    return [];\n  }\n  const width = grid[0].length;\n\n  const stack = getShortestPath({\n    grid,\n    start,\n    end\n  });\n\n  const visited = initVisited(grid, stack);\n  const longestPath = [stack.shift()];\n\n  // the general idea is that we start from the shortest path from start\n  // to end.\n\n  // then, for each segment in that path, we try to see if we can extend\n  // it by adding a pair of adjacent points.\n  // we continue until we run out of pair of points we can add to that path.\n\n  while (stack.length) {\n    const lastInLongestPath = longestPath[longestPath.length - 1];\n    visited[lastInLongestPath] = true;\n    const nextInStack = stack.shift();\n\n    // last in path to next in stack form a segment.\n    // we are trying to see if the 2 points to the right, or 2 points to the left are\n    // valid. if so, we'll add them to the stack.\n\n    // ie - last in path = l, next in stack = n, valid = ., invalid = x\n    // xxxxxx xxxxxxx xxxxxxx xxxxxxx\n    // x.n..x x.....x x.....x x.x...x\n    // x.lx.x x..ln.x xxl...x x.nl..x\n    // x....x x..x..x x.n...x x.....x\n    // xxxxxx xxxxxxx xxxxxxx xxxxxxx\n    //\n    // in each of these 4 examples, 2 points to the left of ln are both valid.\n    // so we can push them to the stack\n    // only one of the 2 points to the right of ln are valid. so we can't push them to the stack\n    // not 100% sure of that, but i think with how we build the path, having 2 points to right\n    // valid and 2 points to left valid is exclusive.\n    // valid points = not visited, not off bounds\n\n    const dx = nextInStack[0] - lastInLongestPath[0];\n    const dy = nextInStack[1] - lastInLongestPath[1];\n\n    const rightPoints = [\n      [lastInLongestPath[0] - dy, lastInLongestPath[1] - dx],\n      [nextInStack[0] - dy, nextInStack[1] - dx]\n    ];\n    const leftPoints = [\n      [lastInLongestPath[0] + dy, lastInLongestPath[1] + dx],\n      [nextInStack[0] + dy, nextInStack[1] + dx]\n    ];\n\n    if (\n      isValid(...rightPoints[0], visited, height, width) &&\n      isValid(...rightPoints[1], visited, height, width)\n    ) {\n      stack.unshift(nextInStack);\n      stack.unshift(rightPoints[1]);\n      stack.unshift(rightPoints[0]);\n      visited[rightPoints[0]] = true;\n      visited[rightPoints[1]] = true;\n    } else {\n      if (\n        isValid(...leftPoints[0], visited, height, width) &&\n        isValid(...leftPoints[1], visited, height, width)\n      ) {\n        stack.unshift(nextInStack);\n        stack.unshift(leftPoints[1]);\n        stack.unshift(leftPoints[0]);\n        visited[leftPoints[0]] = true;\n        visited[leftPoints[1]] = true;\n      } else {\n        // we can't add either both right points or both left points to stack.\n        // Great! we add nextInStack to the path, and continue.\n        longestPath.push(nextInStack);\n      }\n    }\n  }\n\n  return longestPath;\n}\n\nfunction getActionsFromGrid(grid) {\n  // we can deduce the direction from content of the grid but why would we\n  // leaving this in place if we decide the user can initiate the snake however\n  // they want\n  return grid.map((row, r) =>\n    row.map((cell, c) => {\n      if (!cell) {\n        return undefined;\n      }\n      // we're guaranteed that non empty cells are never at the edge of grid\n      if (grid[r - 1][c] < cell || grid[r + 1][c] > cell) {\n        return UP;\n      }\n      if (grid[r][c - 1] > cell || grid[r][c + 1] < cell) {\n        return RIGHT;\n      }\n      if (grid[r - 1][c] > cell || grid[r + 1][c] < cell) {\n        return DOWN;\n      }\n      if (grid[r][c - 1] < cell || grid[r][c + 1] > cell) {\n        return LEFT;\n      }\n      return undefined;\n    })\n  );\n}\n\nexport function getActionGrid({ grid, path, direction }) {\n  // we have on one hand, grid which is the position of the snake,\n  // and on the other, path which is the longest path from the cell\n  // which is in front of the snake to the one behind its tail.\n\n  // what we want is a lookup table that, for every coordinate that the\n  // head could find itself on, suggest the corresponding, safe action.\n\n  const actionGrid = grid.map(row =>\n    row.map(cell => (cell ? direction : undefined))\n  );\n\n  let node;\n\n  for (let i = 1; i < path.length; i++) {\n    const prev = path[i - 1];\n    node = path[i];\n    const dx = node[0] - prev[0];\n    const dy = node[1] - prev[1];\n    const [c, r] = prev;\n    actionGrid[r][c] = getDir[[dx, dy]];\n  }\n\n  // we should have a complete actionGrid except for the very last node\n  // of path\n\n  // it goes towards the tail of the snake. in our case it's direction\n\n  const [c, r] = node;\n  actionGrid[r][c] = direction;\n\n  return actionGrid;\n}\n\nexport function positionFruit(grid) {\n  const eligiblePositions = grid.reduce(\n    (results, row, r) =>\n      row.reduce((resultRow, cell, c) => {\n        if (cell === 0) {\n          resultRow.push([r, c]);\n        }\n        return resultRow;\n      }, results),\n    []\n  );\n  if (eligiblePositions.length === 0) {\n    return null;\n  }\n  const randomPosition = Math.floor(Math.random() * eligiblePositions.length);\n  return eligiblePositions[randomPosition];\n}\n","import React from 'react';\nimport { FlexRow, FlexColumn, Model } from 'react-sim';\n\nimport {\n  UP,\n  RIGHT,\n  DOWN,\n  LEFT,\n  getRandomInBounds,\n  v,\n  opposite,\n  positionFruit,\n  IS_VERTICAL,\n  IS_HORIZONTAL,\n  getLongestPath,\n  getActionGrid,\n} from './helpers';\n\n// update\n\nexport function updateSnake({ data, params, complete }) {\n  const { actionGrid, grid, direction, head, fruit, length } = data;\n  const { fruitGrowth, height, width } = params;\n  let isFull = true;\n  const updatedGrid = grid.map(row =>\n    row.map(cell => {\n      if (cell === 0 || cell + 1 > length) {\n        isFull = false;\n        return 0;\n      }\n      return cell + 1;\n    })\n  );\n\n  if (isFull) {\n    complete();\n  }\n  // new position of head, based on previous direction\n  const updatedHead = [head[0] + v[direction][0], head[1] + v[direction][1]];\n\n  if (\n    // collision with snake\n    updatedGrid[updatedHead[1]][updatedHead[0]] !== 0 ||\n    // collision with walls\n    updatedHead[0] >= width ||\n    updatedHead[0] < 0 ||\n    updatedHead[1] >= height ||\n    updatedHead[1] < 0\n  ) {\n    // ouch\n    complete();\n  }\n\n  // updating grid\n  updatedGrid[updatedHead[1]][updatedHead[0]] = 1;\n\n  // computing next direction, thanks to the action grid\n  const updatedDirection = actionGrid[updatedHead[1]][updatedHead[0]];\n\n  // checking if fruit is eaten, if so, increasing length - repositioning fruit\n  let updatedLength = length;\n  let updatedFruit = fruit ? [fruit[0], fruit[1]] : null;\n  if (\n    updatedFruit &&\n    updatedHead[0] === fruit[0] &&\n    updatedHead[1] === fruit[1]\n  ) {\n    updatedLength = updatedLength + fruitGrowth;\n    updatedFruit = positionFruit(updatedGrid);\n  }\n\n  return {\n    actionGrid,\n    direction: updatedDirection,\n    fruit: updatedFruit,\n    grid: updatedGrid,\n    head: updatedHead,\n    length: updatedLength,\n  };\n}\n\n// init\n\nfunction initSnake({ height, width, initialLength }) {\n  const direction = Math.floor(Math.random() * 4);\n\n  // bounding box where the snake head can be\n\n  const minX = direction === RIGHT ? initialLength + 2 : 2;\n  const maxX = width - 1 - (direction === LEFT ? initialLength + 2 : 2);\n  const minY = direction === DOWN ? initialLength + 2 : 2;\n  const maxY = height - 1 - (direction === UP ? initialLength + 2 : 2);\n\n  // position of snake head\n\n  const xHead = getRandomInBounds(minX, maxX);\n  const yHead = getRandomInBounds(minY, maxY);\n\n  // initial empty grid\n\n  const grid = [];\n  for (let i = 0; i < height; i++) {\n    const row = [];\n    for (let j = 0; j < width; j++) {\n      row.push(0);\n    }\n    grid.push(row);\n  }\n\n  let tail = [];\n\n  // positioning snake\n\n  for (let s = 0; s < initialLength; s++) {\n    // opposite[direction] - if direction is right, we\n    // want to draw snake left of its head\n\n    // v - x,y vector of movement for a direction\n\n    const x = xHead + s * v[opposite[direction]][0];\n    const y = yHead + s * v[opposite[direction]][1];\n\n    // grid - 1 = head, 2 ... n = body of snake, 0 = empty cells\n    grid[y][x] = s + 1;\n    // tail will be overwritten until the actual tail isn't\n    tail = [x, y];\n  }\n\n  const behindTail = [\n    tail[0] + v[opposite[direction]][0],\n    tail[1] + v[opposite[direction]][1],\n  ];\n  const head = [xHead, yHead];\n  const frontOfSnake = [xHead + v[direction][0], yHead + v[direction][1]];\n\n  const fruit = positionFruit(grid);\n\n  const longestPath = getLongestPath({\n    grid,\n    start: frontOfSnake,\n    end: behindTail,\n  });\n  const actionGrid = getActionGrid({ grid, path: longestPath, direction });\n\n  return {\n    head: [xHead, yHead],\n    grid,\n    direction,\n    actionGrid,\n    fruit,\n    length: initialLength,\n  };\n}\n\nconst SnakeBit = ({ size, color, directionNext, directionPrev, weight}) => {\n  if (directionNext === null) {\n    // tail\n    return SnakeBit({\n      size,\n      color,\n      weight,\n      directionNext: directionPrev,\n      directionPrev: null,\n    });\n  }\n  const margin = (1 - weight) / 2;\n  const ms = margin * size;\n  const ws = weight * size;\n\n  if (directionPrev === null) {\n    // head, or \"reversed tail\"\n    return (\n      <div style={{ height: size, width: size, position: 'relative' }}>\n        <div\n          style={{\n            borderRadius: '50%',\n            height: ws,\n            width: ws,\n            background: color,\n            left: ms,\n            top: ms,\n            position: 'absolute',\n          }}\n        />\n        <div\n          style={{\n            position: 'absolute',\n            background: color,\n            ...(IS_VERTICAL[directionNext]\n              ? { width: ws, left: ms, height: size / 2 }\n              : { width: size / 2, top: ms, height: ws }),\n            ...(directionNext === UP ? { top: 0 } : {}),\n            ...(directionNext === DOWN ? { bottom: 0 } : {}),\n            ...(directionNext === LEFT ? { left: 0 } : {}),\n            ...(directionNext === RIGHT ? { right: 0 } : {}),\n          }}\n        />\n      </div>\n    );\n  }\n  if (directionNext === opposite[directionPrev]) {\n    // vertical, or horizontal\n    return (\n      <div style={{ height: size, width: size, position: 'relative' }}>\n        <div\n          style={{\n            position: 'absolute',\n            background: color,\n            ...(IS_VERTICAL[directionNext]\n              ? {\n                  width: ws,\n                  height: size,\n                  left: ms,\n                }\n              : { width: size, height: ws, top: ms }),\n          }}\n        />\n      </div>\n    );\n  }\n  // corner\n\n  const goesUp = directionNext === UP || directionPrev === UP;\n  const goesLeft = directionNext === LEFT || directionPrev === LEFT;\n\n  const direction = goesUp\n    ? goesLeft\n      ? 'topleft'\n      : 'topright'\n    : goesLeft\n    ? 'bottomleft'\n    : 'bottomright';\n\n  const borderRadius = {\n    topleft: '0 0 100% 0',\n    topright: '0 0 0 100%',\n    bottomleft: '0 100% 0 0',\n    bottomright: '100% 0 0 0',\n  }[direction];\n\n  const position = {\n    ...(goesUp ? { top: 0 } : { bottom: 0 }),\n    ...(goesLeft ? { left: 0 } : { right: 0 }),\n  };\n\n  const cornerStyles = {\n    borderRadius,\n    ...position,\n  };\n\n  return (\n    <div\n      style={{\n        height: size,\n        width: size,\n        position: 'relative',\n        overflow: 'hidden',\n      }}\n    >\n      <div\n        style={{\n          position: 'absolute',\n          background: color,\n          width: ws + ms,\n          height: ws + ms,\n          ...cornerStyles,\n        }}\n      />\n      <div\n        style={{\n          position: 'absolute',\n          background: 'white',\n          width: ms,\n          height: ms,\n          ...cornerStyles,\n        }}\n      />\n    </div>\n  );\n};\n\nconst ActionBit = ({ size, action }) => (\n  <div\n    style={{\n      boxSizing: 'border-box',\n      position: 'relative',\n      height: size,\n      width: size,\n      border: '1px solid #eee',\n    }}\n  >\n    <div\n      style={{\n        position: 'absolute',\n        height: 0,\n        width: size - 1,\n        border: '1px dashed #555',\n        transformOrigin: '0 100%',\n        left: (size - 1) / 2,\n        top: (size - 1) / 2,\n        transform: `rotate(${(action - 1) * 90}deg)`,\n      }}\n    />\n  </div>\n);\n\nexport class SnakeFrame extends React.Component {\n  static defaultProps = {\n    width: 30,\n    height: 30,\n    initialLength: 4,\n  };\n  renderAG = () => {\n    const { actionGrid } = this.props?.data;\n    if (!actionGrid) {\n      return null;\n    }\n    const { cellSize: size } = this.props.params;\n\n    return (\n      <div className=\"actions\" style={{ position: 'absolute' }}>\n        {actionGrid.map((row, r) => (\n          <FlexRow key={`ar-${r}`}>\n            {row.map((cell, c) => (\n              <ActionBit size={size} action={cell} key={`arc-${r}-${c}`} />\n            ))}\n          </FlexRow>\n        ))}\n      </div>\n    );\n  };\n\n  renderSnake = () => {\n    const { cellSize: size } = this.props.params;\n    const { grid, fruit } = this.props?.data;\n    if (!grid) {\n      return null;\n    }\n    return (\n      <FlexColumn className=\"snake\">\n        {grid.map((row, r) => (\n          <FlexRow key={`sr-${r}`}>\n            {row.map((cell, c) => {\n              if (cell === 0) {\n                return (\n                  <div\n                    key={`fruit-${r}-${c}`}\n                    style={{\n                      width: size,\n                      height: size,\n                      display: 'flex',\n                      alignItems: 'center',\n                      justifyContent: 'center',\n                    }}\n                  >\n                    {c === fruit[0] && r === fruit[1] ? '🍎' : ''}\n                  </div>\n                );\n              } else {\n                let directionNext = null;\n                let directionPrev = null;\n                if (grid[r][c + 1]) {\n                  if (grid[r][c + 1] === cell + 1) {\n                    directionPrev = RIGHT;\n                  }\n                  if (grid[r][c + 1] === cell - 1) {\n                    directionNext = RIGHT;\n                  }\n                }\n                if (grid[r][c - 1]) {\n                  if (grid[r][c - 1] === cell + 1) {\n                    directionPrev = LEFT;\n                  }\n                  if (grid[r][c - 1] === cell - 1) {\n                    directionNext = LEFT;\n                  }\n                }\n                if (grid[r + 1] && grid[r + 1][c]) {\n                  if (grid[r + 1][c] === cell + 1) {\n                    directionPrev = DOWN;\n                  }\n                  if (grid[r + 1][c] === cell - 1) {\n                    directionNext = DOWN;\n                  }\n                }\n                if (grid[r - 1] && grid[r - 1][c]) {\n                  if (grid[r - 1][c] === cell + 1) {\n                    directionPrev = UP;\n                  }\n                  if (grid[r - 1][c] === cell - 1) {\n                    directionNext = UP;\n                  }\n                }\n                return (\n                  <SnakeBit\n                    size={size}\n                    weight={0.8}\n                    color=\"green\"\n                    directionNext={directionNext}\n                    directionPrev={directionPrev}\n                    key={`src-${r}-${c}`}\n                  />\n                );\n              }\n            })}\n          </FlexRow>\n        ))}\n      </FlexColumn>\n    );\n  };\n  renderFruit() {}\n  render() {\n    const { data } = this.props;\n    if (data === null) {\n      return null;\n    }\n\n    const { actionGrid, grid } = data;\n    const { width, height, cellSize } = this.props.params;\n    return (\n      <div\n        style={{\n          boxSizing: 'content-box',\n          width: width * cellSize,\n          height: height * cellSize,\n          border: '2px solid black',\n          padding: cellSize,\n        }}\n      >\n        {this.renderAG()}\n        {this.renderSnake()}\n        {this.renderFruit()}\n      </div>\n    );\n  }\n}\n\nconst Snake = () => (\n  <Model\n    auto={false}\n    maxTime={Infinity}\n    initData={initSnake}\n    initialParams={{\n      cellSize: 25,\n      fruitGrowth: 4,\n      height: 20,\n      width: 20,\n      initialLength: 4,\n    }}\n    updateData={updateSnake}\n  >\n    <SnakeFrame />\n  </Model>\n);\n\nexport default Snake;\n","import * as React from 'react'\n  /* @jsx mdx */\nimport { mdx } from '@mdx-js/react';\n/* @jsx mdx */\n\nimport Snake from '../../components/examples/snake/index';\nexport const _frontmatter = {\n  \"Title\": \"Snake\"\n};\n\nconst makeShortcode = name => function MDXDefaultShortcode(props) {\n  console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n  return <div {...props} />;\n};\n\nconst layoutProps = {\n  _frontmatter\n};\nconst MDXLayout = \"wrapper\";\nexport default function MDXContent({\n  components,\n  ...props\n}) {\n  return <MDXLayout {...layoutProps} {...props} components={components} mdxType=\"MDXLayout\">\n\n    <h1>{`Snake`}</h1>\n    <Snake mdxType=\"Snake\" />\n\n    </MDXLayout>;\n}\n;\nMDXContent.isMDXComponent = true;\n      "],"sourceRoot":""}