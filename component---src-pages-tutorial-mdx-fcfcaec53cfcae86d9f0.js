(window.webpackJsonp=window.webpackJsonp||[]).push([[69],{"kX+8":function(e,n,t){"use strict";t.d(n,"a",(function(){return b})),t.d(n,"b",(function(){return h})),t.d(n,"c",(function(){return p})),t.d(n,"d",(function(){return m}));t("E5k/"),t("n0hJ"),t("YBKJ"),t("HQhv");var a=t("q1tI"),i=t.n(a),l=t("1uUR"),r=t("sCKr"),o="0000010000000000010000000000\n0000000100010010000000000000\n1110001000000000000000000001\n1010000000000000000000000000\n0000000000100000000010110000\n0100000101010100000000000001\n0000000000010100000001000001\n0000000011100100000000100001\n0000010000000000000000010000\n0000000000010100000000000100".split("\n").map((function(e){return e.split("").map(Number)}));function s(e,n,t){var a=t.length;if(!a)return 0;for(var i=t[0].length,l=0,r=-1;r<=1;r++)for(var o=-1;o<=1;o++){var s=e+r,c=n+o;s<i&&s>0&&c<a&&c>0&&(s!==e||c!==n)&&(l+=t[c][s])}return l}function c(e){var n=e.data,t=e.complete,a=0,i=n.map((function(e,t){return e.map((function(e,i){var l=s(i,t,n);return e&&(l<2||l>3)?(a++,0):e||3!==l?e:(a++,1)}))}));return 0===a&&t(),i}function d(e){var n=e.data;return n.map((function(e,t){return e.map((function(e,a){var i=s(a,t,n);return e&&(i<2||i>3)?0:e||3!==i?e:1}))}))}function u(e,n){var t=e.height,a=e.width,i=e.density;return void 0===n&&(n=Math.random),Array(t).fill(0).map((function(e){return Array(a).fill(0).map((function(){return Number(n()<i)}))}))}var b=function(){return i.a.createElement(r.a,{initData:u,initialParams:{height:10,width:28,density:.15}},i.a.createElement(l.c,null))},h=function(){return i.a.createElement(r.a,{initData:function(){return o},updateData:d,initialParams:{height:10,width:28,density:.15}},i.a.createElement(l.c,null))},p=function(){return i.a.createElement(r.a,{initData:function(){return o},updateData:c,initialParams:{height:10,width:28,density:.15}},i.a.createElement(l.c,null))},m=function(){return i.a.createElement(r.a,{controls:{param:"density",resetOnChange:!0,maxValue:1,step:.01,label:"Grid density"},showTimeSlider:!1,initData:u,updateData:c,initialParams:{height:10,width:28,density:.15}},i.a.createElement(l.c,null))};n.e=function(e){return i.a.createElement(r.a,Object.assign({auto:!1,controls:{param:"density",maxValue:1,step:.01,resetOnChange:!0,label:"Grid density"},showTimeSlider:!1,updateData:c,delay:100,initData:u,initialParams:{height:28,width:28,density:.15}},e),i.a.createElement(l.c,null))}},uzgh:function(e,n,t){"use strict";t.r(n),t.d(n,"_frontmatter",(function(){return l})),t.d(n,"default",(function(){return o}));t("rzGZ"),t("Dq+y"),t("8npG"),t("Ggvi"),t("E5k/"),t("q1tI");var a=t("7ljp"),i=t("kX+8");var l={Title:"Tutorial"},r={_frontmatter:l};function o(e){var n=e.components,t=function(e,n){if(null==e)return{};var t,a,i={},l=Object.keys(e);for(a=0;a<l.length;a++)t=l[a],n.indexOf(t)>=0||(i[t]=e[t]);return i}(e,["components"]);return Object(a.b)("wrapper",Object.assign({},r,t,{components:n,mdxType:"MDXLayout"}),Object(a.b)("p",null,"To illustrate how React-Sim works, let's recreate John Conway's game of life."),Object(a.b)("p",null,"Our finished demo:"),Object(a.b)(i.e,{mdxType:"GameOfLife"}),Object(a.b)("h1",{id:"setup"},"Setup"),Object(a.b)("p",null,"This assumes you have a running React project. If not, check out ",Object(a.b)("a",Object.assign({parentName:"p"},{href:"http://create-react-app.dev"}),"create-react-app"),"."),Object(a.b)("p",null,"In your project, install react-sim:"),Object(a.b)("pre",null,Object(a.b)("code",Object.assign({parentName:"pre"},{className:"language-bash"}),"npm install react-sim\n")),Object(a.b)("p",null,"And start a new file."),Object(a.b)("pre",null,Object(a.b)("code",Object.assign({parentName:"pre"},{className:"language-jsx"}),"import React from 'react';\nimport {Model} from 'react-sim';\n\nconst GameOfLife = () => <Model />;\n\nexport default GameOfLife;\n")),Object(a.b)("p",null,"You'll have a very simple model up and running, but that is not game of life."),Object(a.b)("p",null,"To get our simulation started, we need:"),Object(a.b)("ul",null,Object(a.b)("li",{parentName:"ul"},"a way to initialize the data,"),Object(a.b)("li",{parentName:"ul"},"a way to update data after each tick,"),Object(a.b)("li",{parentName:"ul"},"a way to render the data, and"),Object(a.b)("li",{parentName:"ul"},"controls.")),Object(a.b)("p",null,"Let's build all this!"),Object(a.b)("h1",{id:"initializing-the-data"},"Initializing the data"),Object(a.b)("p",null,"Now, we're going to add a function to initialize our data.\nThe data will look like a 2d grid with random 0s or 1s, corresponding to whether a cell is full or not.\nSo, to initiate our grid, we need to know its dimensions, and we can also control how full our grid is going to be.\nSo, we'll give three arguments to this function: height, width and density.\nHeight and width will be integers, the number of cells in each dimension, and density will be a value between 0 and 1.\nThe lower density is, the emptier the grid will be."),Object(a.b)("p",null,"Add a function:"),Object(a.b)("pre",null,Object(a.b)("code",Object.assign({parentName:"pre"},{className:"language-jsx"}),"function initGrid({ height, width, density }) {\n  return Array(height)\n    .fill(0)\n    .map(row =>\n      Array(width)\n        .fill(0)\n        .map(() => Number(Math.random()) < density)\n    );\n}\n")),Object(a.b)("p",null,"The arguments to initGrid should come from the model's params."),Object(a.b)("p",null,"So let's change ",Object(a.b)("inlineCode",{parentName:"p"},"const GameOfLife = () => <Model />;")," into:"),Object(a.b)("pre",null,Object(a.b)("code",Object.assign({parentName:"pre"},{className:"language-jsx"}),"const GameOfLife = () => (\n  <Model\n    initialParams={{\n      height: 28,\n      width: 28,\n      density: 0.15\n    }}\n    initData={initGrid}\n  />\n)\n")),Object(a.b)("p",null,"Now, when the simulation will start, data will be updated to a random grid."),Object(a.b)("h1",{id:"rendering-the-data"},"Rendering the data"),Object(a.b)("p",null,"Let's create a Frame component to render our data."),Object(a.b)("pre",null,Object(a.b)("code",Object.assign({parentName:"pre"},{className:"language-jsx"}),"const Frame = ({ data = [[]], size = 12, initData }) => (\n  <div>\n    {data.map((row, index) => (\n      <div\n        key={`r-${index}`}\n        styles={{ display: 'flex', flexDirection: 'row', height: size }}\n      >\n        {row.map((cell, index) => (\n          <div\n            key={`c-${index}`}\n            style={{\n              width: size,\n              background: cell ? '#000' : 'none',\n            }}\n          />\n        ))}\n      </div>\n    ))}\n  </div>\n);\n")),Object(a.b)("p",null,"Now, let's update our model:"),Object(a.b)("pre",null,Object(a.b)("code",Object.assign({parentName:"pre"},{className:"language-jsx"}),"const GameOfLife = () => (\n  <Model\n    initialParams={{\n      height: 28,\n      width: 28,\n      density: 0.15\n    }}\n    initData={initGrid}\n  >\n    <Frame />\n  </Model>\n)\n")),Object(a.b)("p",null,"Nothing super unusual, we literally display a black square if a cell is full and nothing if it isn't."),Object(a.b)("p",null,"This frame is actually a common pattern, so there's a ",Object(a.b)("a",Object.assign({parentName:"p"},{href:"/react-sim/frame-helpers"}),"frame helper")," for it: ",Object(a.b)("a",Object.assign({parentName:"p"},{href:"/react-sim/frame-helpers/grid"}),"Grid."),".\nWe can simply substitute our Frame by Grid, like so:"),Object(a.b)("pre",null,Object(a.b)("code",Object.assign({parentName:"pre"},{className:"language-jsx"}),"import React from 'react';\nimport {Grid, Model} from 'react-sim';\n\n// ...\n\nconst GameOfLife = () => (\n  <Model\n    initialParams={{\n      height: 28,\n      width: 28,\n      density: 0.15\n    }}\n    initData={initGrid}\n  >\n    <Grid />\n  </Model>\n)\n")),Object(a.b)(i.a,{mdxType:"Step2"}),Object(a.b)("p",null,"That's what we have at this point. Now we can display our random grid, but it doesn't change as the simulation plays, because we're not updating the data. Let's fix that."),Object(a.b)("h1",{id:"updating-data"},"Updating data"),Object(a.b)("p",null,"Next, we're going to create a function that updates our data."),Object(a.b)("p",null,"The rules of the game of life is that after each turn:"),Object(a.b)("ul",null,Object(a.b)("li",{parentName:"ul"},"Any live cell with 2 or 3 live neighbors survive."),Object(a.b)("li",{parentName:"ul"},"Any dead cell with three live neighbors becomes a live cell."),Object(a.b)("li",{parentName:"ul"},"All other live cells die in the next generation. Similarly, all other dead cells stay dead.")),Object(a.b)("p",null,"So, first we need a way to count neighbors of a cell. Let's add this helper function:"),Object(a.b)("pre",null,Object(a.b)("code",Object.assign({parentName:"pre"},{className:"language-jsx"}),"function countNeighbors(x, y, grid) {\n  const height = grid.length;\n  if (!height) {\n    return 0;\n  }\n  const width = grid[0].length;\n\n  let n = 0;\n  for (let xOffset = -1; xOffset <= 1; xOffset++) {\n    for (let yOffset = -1; yOffset <= 1; yOffset++) {\n      const x1 = x + xOffset;\n      const y1 = y + yOffset;\n      if (\n        x1 < width &&\n        x1 > 0 &&\n        y1 < height &&\n        y1 > 0 &&\n        (x1 !== x || y1 !== y)\n      ) {\n        n += grid[y1][x1];\n      }\n    }\n  }\n  return n;\n}\n")),Object(a.b)("p",null,"And now, let's create our update function:"),Object(a.b)("pre",null,Object(a.b)("code",Object.assign({parentName:"pre"},{className:"language-jsx"}),"function updateGrid({ data }) {\n  return data.map((row, y) =>\n    row.map((cell, x) => {\n      const neighbors = countNeighbors(x, y, data);\n      if (cell && (neighbors < 2 || neighbors > 3)) {\n        // living cell has too few or too many neighbors, and dies.\n        return 0;\n      }\n      if (!cell && neighbors === 3) {\n        // dead cell has the right amount of neighbors, and lives!\n        return 1;\n      }\n      // no change\n      return cell;\n    })\n  );\n}\n")),Object(a.b)("p",null,"Finally, let's plug our update function in our model:"),Object(a.b)("pre",null,Object(a.b)("code",Object.assign({parentName:"pre"},{className:"language-jsx"}),"const GameOfLife = () => (\n  <Model\n    initialParams={{\n      height: 24,\n      width: 48,\n      density: 0.15\n    }}\n    initData={initGrid}\n    updateData={updateGrid}\n  >\n    <Frame />\n  </Model>\n)\n")),Object(a.b)(i.b,{mdxType:"Step3"}),Object(a.b)("p",null,"Now, our game of life updates as the simulation plays!"),Object(a.b)("p",null,"There is a problem though - if the data reaches a stable state, ie no new cell live or die, the simulation continues. It would be nice if it stopped in this case."),Object(a.b)("p",null,"Let's change our update function -"),Object(a.b)("pre",null,Object(a.b)("code",Object.assign({parentName:"pre"},{className:"language-jsx"}),"function updateGrid({ data, complete }) {\n  let changes = 0;\n  const updatedGrid = data.map((row, y) =>\n    row.map((cell, x) => {\n      const neighbors = countNeighbors(x, y, data);\n      if (cell && (neighbors < 2 || neighbors > 3)) {\n        // living cell has too few or too many neighbors, and dies.\n        changes++;\n        return 0;\n      }\n      if (!cell && neighbors === 3) {\n        // dead cell has the right amount of neighbors, and lives!\n        changes++;\n        return 1;\n      }\n      // no change\n      return cell;\n    })\n  );\n  if (changes === 0) {\n    complete();\n  }\n  return updatedGrid;\n}\n")),Object(a.b)("p",null,"In your update function, you can access the method ",Object(a.b)("inlineCode",{parentName:"p"},"complete()"),", and so define conditions in this function that will call this method.\nWhen ",Object(a.b)("inlineCode",{parentName:"p"},"complete()")," is called, the simulation stops, until it is reset."),Object(a.b)(i.c,{mdxType:"Step4"}),Object(a.b)("p",null,"Now our simulation will stop if it can't go any further."),Object(a.b)("h1",{id:"controls"},"Controls"),Object(a.b)("p",null,"Right now, the simulation has default controls, which is the ",Object(a.b)("inlineCode",{parentName:"p"},"Timer")," slider.\nWe can see time, we can move the slider back and forth. This will take us back to previous states of the simulation, or take us many steps in the future."),Object(a.b)("p",null,"But let's get rid of the slider for now.\nOn the other hand, it would be nice if we could adjust the density of the grid."),Object(a.b)("p",null,"So let's address these two things."),Object(a.b)("pre",null,Object(a.b)("code",Object.assign({parentName:"pre"},{className:"language-jsx"}),"const GameOfLife = () => (\n  <Model\n    showTimeSlider={false}\n    controls={{\n      param: 'density',\n      maxValue: 1,\n      step: 0.01,\n      label: 'Grid density',\n      resetOnChange: true,\n    }}\n    initData={initGrid}\n    updateData={updateGameOfLifeGrid}\n    initialParams={{\n      height: 24,\n      width: 48,\n      density: 0.15,\n    }}\n  >\n    <Frame />\n  </Model>);\n")),Object(a.b)("p",null,"We can hide the time slider by setting ",Object(a.b)("inlineCode",{parentName:"p"},"showTimeSlider")," to false."),Object(a.b)("p",null,"We're adding a control via the ",Object(a.b)("inlineCode",{parentName:"p"},"controls")," prop. Here we have only one control, so we can use this simple syntax of just passing one object describing the control, with:"),Object(a.b)("ul",null,Object(a.b)("li",{parentName:"ul"},'the param it\'s going to affect ("density"),'),Object(a.b)("li",{parentName:"ul"},"its maxValue, if different from the default of 100,"),Object(a.b)("li",{parentName:"ul"},"its step, if different from the default of 1,"),Object(a.b)("li",{parentName:"ul"},"a label, which is the name of the param, by default."),Object(a.b)("li",{parentName:"ul"},"resetOnChange: we want the simulation to reinitialize if we touch that control.")),Object(a.b)("p",null,"That's it! we now can control the density of the grid."),Object(a.b)(i.d,{mdxType:"Step5"}),Object(a.b)("h1",{id:"wrapping-up"},"Wrapping up"),Object(a.b)("p",null,"The simulation is still super fast, as it refreshes 60 times per second. We can't see patterns so well.\nWe can add a delay between each animation tick - through the delay property."),Object(a.b)("pre",null,Object(a.b)("code",Object.assign({parentName:"pre"},{className:"language-jsx"}),"const GameOfLife = () => (\n  <Model\n    delay={100}\n    showTimeSlider={false}\n    controls={{\n      param: 'density',\n      maxValue: 1,\n      step: 0.01,\n      label: 'Grid density',\n      resetOnChange: true,\n    }}\n    initData={initGrid}\n    updateData={updateGameOfLifeGrid}\n    initialParams={{\n      height: 24,\n      width: 48,\n      density: 0.15,\n    }}\n  >\n    <Frame />\n  </Model>);\n")),Object(a.b)("p",null,"And that concludes our tutorial!"),Object(a.b)(i.e,{mdxType:"GameOfLife"}))}o.isMDXComponent=!0}}]);
//# sourceMappingURL=component---src-pages-tutorial-mdx-fcfcaec53cfcae86d9f0.js.map