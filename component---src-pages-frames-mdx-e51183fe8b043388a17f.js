(window.webpackJsonp=window.webpackJsonp||[]).push([[61],{EXrp:function(e,t,n){"use strict";n.r(t),n.d(t,"_frontmatter",(function(){return o})),n.d(t,"default",(function(){return c}));var a=n("zLVn"),r=(n("q1tI"),n("7ljp")),i=["components"],o={Title:"Frames"},l={_frontmatter:o};function c(e){var t=e.components,n=Object(a.a)(e,i);return Object(r.b)("wrapper",Object.assign({},l,n,{components:t,mdxType:"MDXLayout"}),Object(r.b)("h1",{id:"how-frames-works"},"How frames works"),Object(r.b)("p",null,"The ",Object(r.b)("inlineCode",{parentName:"p"},"Frames")," are the part of the simulation in charge of rendering the internal state."),Object(r.b)("p",null,"Given a ",Object(r.b)("inlineCode",{parentName:"p"},"data")," and a ",Object(r.b)("inlineCode",{parentName:"p"},"tick")," prop, the ",Object(r.b)("inlineCode",{parentName:"p"},"Frames")," paint a view of that information."),Object(r.b)("p",null,"When the ",Object(r.b)("inlineCode",{parentName:"p"},"Model")," refreshes the animation, it sends updated ",Object(r.b)("inlineCode",{parentName:"p"},"tick")," and ",Object(r.b)("inlineCode",{parentName:"p"},"data")," to the ",Object(r.b)("inlineCode",{parentName:"p"},"Frames"),", so the ",Object(r.b)("inlineCode",{parentName:"p"},"Frames")," rerender and show fresh information."),Object(r.b)("p",null,"The ",Object(r.b)("inlineCode",{parentName:"p"},"Frames")," only job is to render the data. ",Object(r.b)("inlineCode",{parentName:"p"},"updateData")," does the calculation on the data, the ",Object(r.b)("inlineCode",{parentName:"p"},"Model")," manages the animation and ",Object(r.b)("a",{parentName:"p",href:"/react-sim/controls"},"controls")," let the user interact with the Model."),Object(r.b)("p",null,"This is a completely declarative approach, consistent with the React approach."),Object(r.b)("h1",{id:"how-to-connect-frames-and-the-model"},"How to connect Frames and the Model"),Object(r.b)("p",null,"The ",Object(r.b)("inlineCode",{parentName:"p"},"Frames")," receive some information from the ",Object(r.b)("inlineCode",{parentName:"p"},"Model"),"."),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"data")," (anything), the current state of the simulation."),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"tick")," (integer), the progress in the simulation."),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"params")," (object), all the parameters set by the user/author, which don't change over time without intervention."),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"cachedData")," (object), data from previous ",Object(r.b)("inlineCode",{parentName:"li"},"ticks")," of the simulation, and"),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"results")," (array), data from previous completed runs of the simulation,"),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"initData")," (function), the Frame can reinitialize data,"),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"setData")," (function), the Frame can change the data. (so for instance the Frame can be used to let the user enter an initial state of data).")),Object(r.b)("p",null,"The ",Object(r.b)("inlineCode",{parentName:"p"},"Frames")," can be one or more components."),Object(r.b)("p",null,"The easiest way to connect ",Object(r.b)("inlineCode",{parentName:"p"},"Frames")," to a ",Object(r.b)("inlineCode",{parentName:"p"},"Model")," is just to have these components as children of the Model:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-jsx"},"<Model>\n  <MyFrame />\n</Model>\n")),Object(r.b)("p",null,"A component which is a direct child of ",Object(r.b)("inlineCode",{parentName:"p"},"Model")," will receive all of the props above from ",Object(r.b)("inlineCode",{parentName:"p"},"Model"),"."),Object(r.b)("p",null,"This also works if there are several children:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-jsx"},"<Model>\n  <MyFrame />\n  <MyOtherFrame />\n</Model>\n")),Object(r.b)("p",null,"All components will receive these props. The children will be arranged from left to right."),Object(r.b)("p",null,"However, it doesn't work if the components are deep into the tree, ie:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-jsx"},"<Model>\n  <div>\n    <MyFrame />\n  </div>\n</Model>\n")),Object(r.b)("p",null,"Here, ",Object(r.b)("inlineCode",{parentName:"p"},"<MyFrame />")," won't receive the frame props, because it is too deep.\nTo connect ",Object(r.b)("inlineCode",{parentName:"p"},"Frames")," deep in the tree, we can use the ",Object(r.b)("inlineCode",{parentName:"p"},"withFrames")," wrapper."),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-jsx"},"import { withFrames, Model } from 'react-sim';\nimport MyFrame from 'my-frame';\n\nconst MyConnectedFrame = withFrames(MyFrame);\n\nexport default () => (\n  <Model>\n    <div>\n      <MyConnectedFrame />\n    </div>\n  </Model>\n);\n")),Object(r.b)("p",null,"Here, ",Object(r.b)("inlineCode",{parentName:"p"},"<MyConnectedFrame />")," receives the ",Object(r.b)("inlineCode",{parentName:"p"},"frames")," props."))}c.isMDXComponent=!0}}]);
//# sourceMappingURL=component---src-pages-frames-mdx-e51183fe8b043388a17f.js.map