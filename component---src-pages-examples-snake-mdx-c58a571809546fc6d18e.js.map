{"version":3,"sources":["webpack:///./src/pages/examples/snake.mdx"],"names":["_frontmatter","layoutProps","MDXContent","components","props","mdxType","parentName","isMDXComponent"],"mappings":"gRAMO,IAAMA,EAAe,CAC1B,MAAS,SAQLC,EAAc,CAClBD,gBAGa,SAASE,EAAT,GAGZ,IAFDC,EAEC,EAFDA,WACGC,E,oIACF,mBACD,OAAO,YALS,UAKT,iBAAeH,EAAiBG,EAAhC,CAAuCD,WAAYA,EAAYE,QAAQ,cAE5E,iBAAQ,CACN,GAAM,SADR,SAGA,YAAC,IAAD,CAAOA,QAAQ,UACf,0EAA2D,+BAAGC,WAAW,KAAQ,CAC7E,KAAQ,2DAD+C,0DAA3D,OAGA,qTACA,mDAAkC,sBAAQA,WAAW,KAAnB,WAAlC,kJACA,8DACA,6EACA,2FAA0E,sBAAQA,WAAW,KAAnB,sBAA1E,6JACsH,sBAAQA,WAAW,KAAnB,iBADtH,iCAEA,6JACA,kDACA,wHACA,gDAA+B,kBAAIA,WAAW,KAAf,iBAA/B,8PAEA,YAAC,IAAD,CAAWD,QAAQ,cACnB,8DAA6C,kBAAIC,WAAW,KAAf,OAA7C,oNAKJJ,EAAWK,gBAAiB","file":"component---src-pages-examples-snake-mdx-c58a571809546fc6d18e.js","sourcesContent":["import * as React from 'react'\n  /* @jsx mdx */\nimport { mdx } from '@mdx-js/react';\n/* @jsx mdx */\n\nimport { Snake, SnakeGrid } from '../../components/examples/';\nexport const _frontmatter = {\n  \"Title\": \"Snake\"\n};\n\nconst makeShortcode = name => function MDXDefaultShortcode(props) {\n  console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n  return <div {...props} />;\n};\n\nconst layoutProps = {\n  _frontmatter\n};\nconst MDXLayout = \"wrapper\";\nexport default function MDXContent({\n  components,\n  ...props\n}) {\n  return <MDXLayout {...layoutProps} {...props} components={components} mdxType=\"MDXLayout\">\n\n    <h1 {...{\n      \"id\": \"snake\"\n    }}>{`Snake`}</h1>\n    <Snake mdxType=\"Snake\" />\n    <p>{`This model tries to win the game of `}{`[Snake]`}{`(`}<a parentName=\"p\" {...{\n        \"href\": \"https://en.wikipedia.org/wiki/Snake_(video_game_genre)\"\n      }}>{`https://en.wikipedia.org/wiki/Snake_(video_game_genre)`}</a>{`>).`}</p>\n    <p>{`A snake moves on a 2d grid. It can go straight, turn left or right. If it hits the borders of the grid or a part of its body, the game is over. If the snake eats a fruit, it grows in size. The goal of the game is to eat all the fruits, until the snake covers the entirety of the grid.`}</p>\n    <p>{`If the snake can stay on a `}<strong parentName=\"p\">{`circuit`}</strong>{` that covers the entirety of the grid, it can just loop that circuit endlessly, eat all the fruits and never collide with itself or the walls.`}</p>\n    <p>{`But it could be very slow to do that.`}</p>\n    <p>{`So instead, the snake tries to find better circuits.`}</p>\n    <p>{`Whenever it eats a fruit, and a new fruit appears, the snake finds `}<strong parentName=\"p\">{`the quickest route`}</strong>{` from its head to the new fruit.\nThen, it tries to find a route that goes from the fruit to its tail, and covers all the free tiles (in other words, the `}<strong parentName=\"p\">{`longest route`}</strong>{` from its fruit to the tail.)`}</p>\n    <p>{`If the snake can find such a route, then there is another safe circuit it can take - only this one will take it to the fruit sooner.`}</p>\n    <p>{`So, it updates its route.`}</p>\n    <p>{`Finding a quickest path between two points on a grid is easy, but how to find the longest path?`}</p>\n    <p>{`We start by finding the `}<em parentName=\"p\">{`shortest path`}</em>{` between these two points. Then, we take this path segment by segment and see each time if we can extend it. When we run out of segments where we can extend the path, we have a long path between the two points.\nThis other model shows how this works:`}</p>\n    <SnakeGrid mdxType=\"SnakeGrid\" />\n    <p>{`This method is not guaranteed to find `}<em parentName=\"p\">{`the`}</em>{` longest path between 2 points - sometimes such a route will leave a couple of cells uncovered. This is why the snake waits to find a circuit that covers every cell in the grid before it updates its circuit.`}</p>\n\n    </MDXLayout>;\n}\n;\nMDXContent.isMDXComponent = true;\n      "],"sourceRoot":""}